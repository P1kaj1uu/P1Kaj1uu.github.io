<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器渲染和原理</title>
      <link href="/2022/06/27/liu-lan-qi-xuan-ran-he-yuan-li/"/>
      <url>/2022/06/27/liu-lan-qi-xuan-ran-he-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="一、浏览器的渲染过程"><a href="#一、浏览器的渲染过程" class="headerlink" title="一、浏览器的渲染过程"></a>一、浏览器的渲染过程</h3><ul><li><img src="/2022/06/27/liu-lan-qi-xuan-ran-he-yuan-li/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png" style="zoom:60%;"></li><li><p>注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p></li><li><p><strong>渲染过程解读如下</strong>：</p><ul><li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成 CSSOM 规则树。</li><li>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ul></li></ul><h3 id="二、浏览器渲染优化"><a href="#二、浏览器渲染优化" class="headerlink" title="二、浏览器渲染优化"></a>二、浏览器渲染优化</h3><h4 id="1-针对JavaScript"><a href="#1-针对JavaScript" class="headerlink" title="1.针对JavaScript"></a>1.针对JavaScript</h4><ul><li>JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化<ul><li>尽量将JavaScript文件放在<strong>body的最后</strong></li><li><code>&lt;scipt&gt;</code>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 <strong>async</strong> 属性和 <strong>defer</strong> 属性来异步引入，两者都是去异步加载外部的JS文件，<strong>不会阻塞DOM的解析</strong>（尽量使用异步加载）。三者的区别如下：<ul><li>script 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面</li><li>async 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序</li><li>defer 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行</li></ul></li></ul></li></ul><h4 id="2-针对CSS"><a href="#2-针对CSS" class="headerlink" title="2.针对CSS"></a>2.针对CSS</h4><ul><li>使用CSS有三种方式：使用link、@import、内联样式，其中link和@import都是导入外部样式。它们之间的区别：<ul><li>link：浏览器会派发一个新的线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</li><li>@import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</li><li>style：GUI直接渲染</li><li>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</li></ul></li><li>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以<strong>CSS一般写在headr中</strong>，让浏览器尽快发送请求去获取css样式</li></ul><h4 id="3-针对DOM树、CSSOM规则树"><a href="#3-针对DOM树、CSSOM规则树" class="headerlink" title="3.针对DOM树、CSSOM规则树"></a>3.针对DOM树、CSSOM规则树</h4><ul><li>HTML文件的代码<strong>层级尽量不要太深</strong></li><li><strong>使用语义化的标签</strong>，来避免不标准语义化的特殊处理</li><li><strong>减少CSS代码的层级</strong>，因为选择器是从右向左进行解析的</li></ul><h4 id="4-减少回流与重绘"><a href="#4-减少回流与重绘" class="headerlink" title="4.减少回流与重绘"></a>4.减少回流与重绘</h4><ul><li>浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列。浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批量处理。这样就会让多次的回流、重绘变成一次回流重绘。</li><li><strong>CSS</strong>：<ul><li>避免设置多层内联样式</li><li>如果需要设置动画效果，最好使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li><li>避免使用CSS表达式（例如：calc()）</li></ul></li><li><strong>JS</strong>：<ul><li>避免频繁操作样式，最好将样式列表定义为class并一次性更改class属性</li><li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中</li><li>可以先为元素设置为不可见：display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘</li></ul></li></ul><h3 id="三、渲染过程中遇到-JS-文件如何处理"><a href="#三、渲染过程中遇到-JS-文件如何处理" class="headerlink" title="三、渲染过程中遇到 JS 文件如何处理"></a>三、渲染过程中遇到 JS 文件如何处理</h3><ul><li>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议<strong>将 script 标签放在 body 标签底部</strong>的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以<strong>给 script 标签添加 defer 或者 async 属性</strong>。</li></ul><h3 id="四、文档的预解析"><a href="#四、文档的预解析" class="headerlink" title="四、文档的预解析"></a>四、文档的预解析</h3><ul><li>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，<strong>预解析并不改变 DOM 树</strong>，它将这个工作留给主解析过程，自己<strong>只解析外部资源的引用</strong>，比如外部脚本、样式表及图片。</li></ul><h3 id="五、CSS-如何阻塞文档解析"><a href="#五、CSS-如何阻塞文档解析" class="headerlink" title="五、CSS 如何阻塞文档解析"></a>五、CSS 如何阻塞文档解析</h3><ul><li>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，<strong>浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析</strong>。</li></ul><h3 id="六、优化关键渲染路径"><a href="#六、优化关键渲染路径" class="headerlink" title="六、优化关键渲染路径"></a>六、优化关键渲染路径</h3><ul><li><strong>优化方法如下</strong>：<ul><li>对关键路径进行分析和特性描述：资源数、字节数、长度</li><li>最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等</li><li>优化关键字节数以缩短下载时间（往返次数）</li><li>优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</li></ul></li></ul><h3 id="七、阻塞渲染的情况"><a href="#七、阻塞渲染的情况" class="headerlink" title="七、阻塞渲染的情况"></a>七、阻塞渲染的情况</h3><ul><li>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序开发优化</title>
      <link href="/2022/06/27/xiao-cheng-xu-kai-fa-you-hua/"/>
      <url>/2022/06/27/xiao-cheng-xu-kai-fa-you-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="一、开发优化一"><a href="#一、开发优化一" class="headerlink" title="一、开发优化一"></a>一、开发优化一</h3><h4 id="1-使用Vant-Weapp"><a href="#1-使用Vant-Weapp" class="headerlink" title="1.使用Vant Weapp"></a>1.使用Vant Weapp</h4><h5 id="1-1-什么是Vant-Weapp"><a href="#1-1-什么是Vant-Weapp" class="headerlink" title="1.1 什么是Vant Weapp"></a>1.1 什么是Vant Weapp</h5><blockquote><p><a href="https://vant-contrib.gitee.io/vant-weapp/#/home">Vant Weapp官网链接</a></p></blockquote><ul><li>Vant Weapp是有赞前端团队开源的一套<strong>小程序UI组件库</strong>，助力开发者快速搭建小程序应用。它所使用的是<strong>MIT开源许可协议</strong>，对商业使用比较友好。</li></ul><h5 id="1-2-安装Vant-Weapp组件库"><a href="#1-2-安装Vant-Weapp组件库" class="headerlink" title="1.2 安装Vant Weapp组件库"></a>1.2 安装Vant Weapp组件库</h5><blockquote><p><a href="https://youzan.github.io/vant-weapp/#/quickstart">安装快速上手</a></p></blockquote><ul><li>在小程序项目中，安装组件库步骤如下：<ul><li><code>npm i @vant/weapp -S --production</code></li><li>构建npm包</li><li>修改app.json，将 app.json 中的 <code>"style": "v2"</code> 移除</li></ul></li></ul><h5 id="1-3-使用Vant-Weapp组件库"><a href="#1-3-使用Vant-Weapp组件库" class="headerlink" title="1.3 使用Vant Weapp组件库"></a>1.3 使用Vant Weapp组件库</h5><blockquote><p><a href="https://youzan.github.io/vant-weapp/#/quickstart">使用快速上手</a></p></blockquote><ul><li><p><strong>引入组件</strong></p><ul><li><p>以 Button 组件为例，只需要在<code>app.json</code>或<code>index.json</code>中配置 Button 对应的路径即可。</p></li><li><p>所有组件文档中的引入路径均以 npm 安装为例，如果你是通过下载源代码的方式使用 @vant/weapp，请将路径修改为项目中 @vant/weapp 所在的目录。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 通过 npm 安装</span><span class="token comment">// app.json</span><span class="token string-property property">"usingComponents"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token string-property property">"van-button"</span><span class="token operator">:</span> <span class="token string">"@vant/weapp/button/index"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>使用组件</strong></p><ul><li><p>引入组件后，可以在 wxml 中直接使用组件</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>van-button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>van-button</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ul><h5 id="1-4-使用css变量定制主题样式"><a href="#1-4-使用css变量定制主题样式" class="headerlink" title="1.4 使用css变量定制主题样式"></a>1.4 使用css变量定制主题样式</h5><blockquote><p><a href="https://youzan.github.io/vant-weapp/#/theme">定制主题</a></p></blockquote><ul><li>在app.wxss中，写入CSS变量，即可对全局生效。</li></ul><h3 id="二、开发优化二"><a href="#二、开发优化二" class="headerlink" title="二、开发优化二"></a>二、开发优化二</h3><h4 id="1-API的Promise化"><a href="#1-API的Promise化" class="headerlink" title="1.API的Promise化"></a>1.API的Promise化</h4><h5 id="1-1-什么是API的Promise化"><a href="#1-1-什么是API的Promise化" class="headerlink" title="1.1 什么是API的Promise化"></a>1.1 什么是API的Promise化</h5><ul><li><strong>API Promise化</strong>，指的是通过<strong>额外的配置</strong>，将官方提供的、基于回调函数的异步API，升级改造为<strong>基于Promise的异步API</strong>，从而提高代码的可读性、维护性，避免回调地狱的问题。</li></ul><h5 id="1-2-实现API的Promise化"><a href="#1-2-实现API的Promise化" class="headerlink" title="1.2 实现API的Promise化"></a>1.2 实现API的Promise化</h5><ul><li><p>在小程序中，实现API Promise化主要依赖于 <code>miniprogram-api-promise</code> 这个第三方的npm包。它的安装和使用步骤如下：</p><ul><li><p>安装：<code>npm install --save miniprogram-api-promise@1.0.4</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 在小程序入口文件中(app.js)，只需调用一次 promisifyAll() 方法</span><span class="token comment">// 即可实现异步API的Promise化</span><span class="token keyword">import</span> <span class="token punctuation">{</span> promisifyAll <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'miniprogram-api-promise'</span><span class="token keyword">const</span> wxp <span class="token operator">=</span> wx<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">promisifyAll</span><span class="token punctuation">(</span>wx<span class="token punctuation">,</span> wxp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注：安装完每个包之后需要重新构建，在对应文件夹下强制删除miniprogram_npm，然后在工具中重新构建npm。</p></li></ul></li></ul><h5 id="1-3-调用Promise化之后的异步API"><a href="#1-3-调用Promise化之后的异步API" class="headerlink" title="1.3 调用Promise化之后的异步API"></a>1.3 调用Promise化之后的异步API</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 页面的 .wxml 结构</span><span class="token operator">&lt;</span>van<span class="token operator">-</span>button type<span class="token operator">=</span><span class="token string">"danger"</span> bindtap<span class="token operator">=</span><span class="token string">"getInfo"</span><span class="token operator">&gt;</span>vant按钮<span class="token operator">&lt;</span><span class="token operator">/</span>van<span class="token operator">-</span>button<span class="token operator">&gt;</span><span class="token comment">// 在页面的 .js 文件中，定义对应的事件处理函数</span><span class="token keyword">async</span> <span class="token function">getInfo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token literal-property property">data</span><span class="token operator">:</span> res <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> wx<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span>        <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'https://www.escook.cn/api/get'</span><span class="token punctuation">,</span>        <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'zs'</span><span class="token punctuation">,</span>            <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">20</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、开发优化三"><a href="#三、开发优化三" class="headerlink" title="三、开发优化三"></a>三、开发优化三</h3><h4 id="1-全局数据共享"><a href="#1-全局数据共享" class="headerlink" title="1.全局数据共享"></a>1.全局数据共享</h4><h5 id="1-1-小程序中的全局共享方案"><a href="#1-1-小程序中的全局共享方案" class="headerlink" title="1.1 小程序中的全局共享方案"></a>1.1 小程序中的全局共享方案</h5><img src="/2022/06/27/xiao-cheng-xu-kai-fa-you-hua/%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB.png" style="zoom:70%;"><h5 id="1-2-小程序全局数据共享MobX步骤"><a href="#1-2-小程序全局数据共享MobX步骤" class="headerlink" title="1.2 小程序全局数据共享MobX步骤"></a>1.2 小程序全局数据共享MobX步骤</h5><blockquote><p><a href="https://blog.csdn.net/m0_61631823/article/details/123929014?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8MobX&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-123929014.142%5Ev24%5Ehuaweicloudv2,157%5Ev15%5Enew_3&amp;spm=1018.2226.3001.4187">参考资料一</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/qq_45708377/article/details/122277394?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8MobX&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-122277394.142%5Ev24%5Ehuaweicloudv2,157%5Ev15%5Enew_3&amp;spm=1018.2226.3001.4187">参考资料二</a></p></blockquote><h3 id="四、开发优化四"><a href="#四、开发优化四" class="headerlink" title="四、开发优化四"></a>四、开发优化四</h3><h4 id="1-分包"><a href="#1-分包" class="headerlink" title="1.分包"></a>1.分包</h4><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html">分包加载官网链接</a></p></blockquote><h3 id="五、提高微信小程序的应用速度的方法"><a href="#五、提高微信小程序的应用速度的方法" class="headerlink" title="五、提高微信小程序的应用速度的方法"></a>五、提高微信小程序的应用速度的方法</h3><h4 id="1-小程序启动加载性能"><a href="#1-小程序启动加载性能" class="headerlink" title="1.小程序启动加载性能"></a>1.小程序启动加载性能</h4><ul><li>控制代码包的大小</li><li>分包加载</li><li>首屏体验（预请求，利用缓存，避免白屏，及时反馈）</li></ul><h4 id="2-小程序渲染性能"><a href="#2-小程序渲染性能" class="headerlink" title="2.小程序渲染性能"></a>2.小程序渲染性能</h4><ul><li>避免不当的使用setData</li><li>使用自定义组件<ul><li>自定义组件的更新并不会影响页面上其他元素的更新</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序路由跳转</title>
      <link href="/2022/06/26/xiao-cheng-xu-lu-you-tiao-zhuan/"/>
      <url>/2022/06/26/xiao-cheng-xu-lu-you-tiao-zhuan/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html">小程序路由跳转官网链接</a></p></blockquote><h3 id="一、声明式导航"><a href="#一、声明式导航" class="headerlink" title="一、声明式导航"></a>一、声明式导航</h3><ul><li>在页面上声明一个<code>&lt;navigator&gt;</code>导航组件</li><li>通过点击<code>&lt;navigator&gt;</code>组件实现页面跳转</li></ul><h4 id="1-导航到tabBar页面"><a href="#1-导航到tabBar页面" class="headerlink" title="1.导航到tabBar页面"></a>1.导航到tabBar页面</h4><ul><li><p><strong>tabBar页面</strong>指的是被配置为tabBar的页面</p></li><li><p>在使用<code>&lt;navigator&gt;</code>组件跳转至指定的tabBar页面时，需要指定<strong>url</strong>和<strong>open-type</strong>属性，其中：</p><ul><li>url表示要跳转的<strong>页面的地址</strong>，必须以 <strong>/</strong> 开头</li><li>open-type表示<strong>跳转的方式</strong>，必须为 <strong>switchTab</strong></li></ul></li><li><p>示例代码如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>navigator</span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/pages/message/message<span class="token punctuation">"</span></span> <span class="token attr-name">open-type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>switchTab<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>导航到消息页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>navigator</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="2-导航到非tabBar页面"><a href="#2-导航到非tabBar页面" class="headerlink" title="2.导航到非tabBar页面"></a>2.导航到非tabBar页面</h4><ul><li><p><strong>非tabBar页面</strong>指的是没有被配置为tabBar的页面</p></li><li><p>在使用<code>&lt;navigator&gt;</code>组件跳转到普通的非tabBar页面时，则需要指定<strong>url</strong>属性和<strong>open-type</strong>属性，其中：</p><ul><li>url表示要跳转的<strong>页面的地址</strong>，必须以 <strong>/</strong> 开头</li><li>open-type表示<strong>跳转的方式</strong>，必须为 <strong>navigate</strong></li></ul></li><li><p>示例代码如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>navigator</span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/pages/info/info<span class="token punctuation">"</span></span> <span class="token attr-name">open-type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>navigate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>导航到info页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>navigator</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 注：为了方便，在导航到非tabBar页面时，open-type="navigate"属性可以省略 --&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="3-后退导航"><a href="#3-后退导航" class="headerlink" title="3.后退导航"></a>3.后退导航</h4><ul><li><p>如果要后退到上一页面或多级页面，则需要指定<strong>open-type</strong>属性<strong>delta</strong>属性，其中：</p><ul><li>open-type 的值必须是 <strong>navigateBack</strong>，表示要<strong>进行后退导航</strong></li><li>delta 的值必须是 <strong>数字</strong>，表示要<strong>后退的层级</strong></li></ul></li><li><p>示例代码如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>navigator</span> <span class="token attr-name">open-type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>navigateBack<span class="token punctuation">"</span></span> <span class="token attr-name">delta</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>返回上一页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>navigator</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 注：为了简便，如果只是后退到上一页面，则可以省略delta属性，因为其默认值就是1 --&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="二、编程式导航"><a href="#二、编程式导航" class="headerlink" title="二、编程式导航"></a>二、编程式导航</h3><ul><li>调用小程序的导航API，实现页面的跳转</li></ul><h4 id="1-导航到tabBar页面-1"><a href="#1-导航到tabBar页面-1" class="headerlink" title="1.导航到tabBar页面"></a>1.导航到tabBar页面</h4><ul><li><p>调用<strong>wx.switchTab(Object object)</strong> 方法，可以跳转到tabBar页面。其中Object<strong>参数对象</strong>的属性列表如下：</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">是否必选</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>url</strong></td><td align="center"><strong>string</strong></td><td align="center"><strong>是</strong></td><td align="center">需要跳转的tabBar页面的路径，路径后面不能带参数</td></tr><tr><td align="center">success</td><td align="center">function</td><td align="center">否</td><td align="center">接口调用成功的回调函数</td></tr><tr><td align="center">fail</td><td align="center">function</td><td align="center">否</td><td align="center">接口调用失败的回调函数</td></tr><tr><td align="center">complete</td><td align="center">function</td><td align="center">否</td><td align="center">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table></li><li><p>基本使用：<code>wx.switchTab({url: '/pages/message/message'})</code></p></li><li><p>示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 页面结构</span><span class="token operator">&lt;</span>button bindtap<span class="token operator">=</span><span class="token string">"gotoMessage"</span><span class="token operator">&gt;</span>跳转到消息页面<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token comment">// 通过编程式导航，跳转到message页面</span>gotoMessage <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wx<span class="token punctuation">.</span><span class="token function">switchTab</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        url<span class="token operator">:</span> '<span class="token operator">/</span>pages<span class="token operator">/</span>message<span class="token operator">/</span>message'    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="2-导航到非tabBar页面-1"><a href="#2-导航到非tabBar页面-1" class="headerlink" title="2.导航到非tabBar页面"></a>2.导航到非tabBar页面</h4><ul><li><p>调用<strong>wx.navigateTo(Object object)</strong> 方法，可以跳转到非tabBar页面。其中Object<strong>参数对象</strong>的属性列表如下：</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">是否必选</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>url</strong></td><td align="center"><strong>string</strong></td><td align="center"><strong>是</strong></td><td align="center">需要跳转到的非tabBar页面的路径，路径后面可以带参数</td></tr><tr><td align="center">success</td><td align="center">function</td><td align="center">否</td><td align="center">接口调用成功的回调函数</td></tr><tr><td align="center">fail</td><td align="center">function</td><td align="center">否</td><td align="center">接口调用失败的回调函数</td></tr><tr><td align="center">complete</td><td align="center">function</td><td align="center">否</td><td align="center">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table></li><li><p>基本使用：<code>wx.navigateTo({url: '/pages/info/info'})</code></p></li><li><p>示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 页面结构</span><span class="token operator">&lt;</span>button bindtap<span class="token operator">=</span><span class="token string">"gotoInfo"</span><span class="token operator">&gt;</span>跳转到<span class="token class-name">Info</span>页面<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token comment">// 通过编程式导航，跳转到Info页面</span>gotoInfo <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wx<span class="token punctuation">.</span><span class="token function">navigateTo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        url<span class="token operator">:</span> '<span class="token operator">/</span>pages<span class="token operator">/</span>info<span class="token operator">/</span>info'    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="3-后退导航-1"><a href="#3-后退导航-1" class="headerlink" title="3.后退导航"></a>3.后退导航</h4><ul><li><p>调用<strong>wx.navigateBack(Object object)</strong> 方法，可以返回上一页面或多级页面。其中Object<strong>参数对象</strong>的属性列表如下：</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">是否必选</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>delta</strong></td><td align="center"><strong>number</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>否</strong></td><td align="center">返回的页面数，如果delta大于现有页面数，则返回首页</td></tr><tr><td align="center">success</td><td align="center">function</td><td align="center"></td><td align="center">否</td><td align="center">接口调用成功的回调函数</td></tr><tr><td align="center">fail</td><td align="center">function</td><td align="center"></td><td align="center">否</td><td align="center">接口调用失败的回调函数</td></tr><tr><td align="center">complete</td><td align="center">function</td><td align="center"></td><td align="center">否</td><td align="center">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table></li><li><p>基本使用：<code>wx.navigateBack({delta: 1})</code></p></li><li><p>示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 页面结构</span><span class="token operator">&lt;</span>button bindtap<span class="token operator">=</span><span class="token string">"gotoBack"</span><span class="token operator">&gt;</span>后退<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token comment">// 通过编程式导航，后退到上一页面</span>gotoBack <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wx<span class="token punctuation">.</span><span class="token function">navigateBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序发布与支付</title>
      <link href="/2022/06/25/xiao-cheng-xu-fa-bu-yu-zhi-fu/"/>
      <url>/2022/06/25/xiao-cheng-xu-fa-bu-yu-zhi-fu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、小程序的发布流程"><a href="#一、小程序的发布流程" class="headerlink" title="一、小程序的发布流程"></a>一、小程序的发布流程</h3><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/release.html#%E5%8F%91%E5%B8%83%E4%B8%8A%E7%BA%BF">小程序协同工作和发布官网链接</a></p></blockquote><h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h4><ul><li>小程序的平台里，开发者完成开发之后，需要在开发者工具提交小程序的代码包，然后在小程序后台发布小程序。</li></ul><h4 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程"></a>2.流程</h4><ol><li>上传代码<ul><li>代码管理服务器上新建分支</li><li>开发测试新需求</li><li>测试完成后，将本地分支合并到 master 分支</li><li>拉取 master 分支最新代码，执行 build 命令生成小程序可执行文件</li><li>开发者工具点击“上传”</li></ul></li><li>提交审核</li><li>发布版本</li></ol><h3 id="二、小程序的支付流程"><a href="#二、小程序的支付流程" class="headerlink" title="二、小程序的支付流程"></a>二、小程序的支付流程</h3><h4 id="1-背景-1"><a href="#1-背景-1" class="headerlink" title="1.背景"></a>1.背景</h4><ul><li>用户通过分享或扫描二维码进入商户小程序，用户选择购买，完成选购流程。</li><li>调起微信支付控件，用户开始输入支付密码。</li><li>密码验证通过，支付成功。商户后台得到支付成功的通知。</li><li>返回商户小程序，显示购买成功。</li><li>微信支付公众号下发支付凭证。</li></ul><h4 id="2-流程-1"><a href="#2-流程-1" class="headerlink" title="2.流程"></a>2.流程</h4><ol><li>打开某小程序，点击直接下单</li><li>wx.login获取用户临时登录凭证code，发送到后端服务器换取openId</li><li>在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器</li><li>服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息</li><li>小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付</li><li>接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付</li><li>鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示</li><li>推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态</li></ol>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序实现与登录</title>
      <link href="/2022/06/25/xiao-cheng-xu-shi-xian-yu-deng-lu/"/>
      <url>/2022/06/25/xiao-cheng-xu-shi-xian-yu-deng-lu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、小程序的实现原理"><a href="#一、小程序的实现原理" class="headerlink" title="一、小程序的实现原理"></a>一、小程序的实现原理</h3><ul><li>在小程序中，渲染层和逻辑层是分开的，双线程同时运行，渲染层和逻辑层这两个通信主体之间的通讯以及通讯主体与第三方服务器之间的通信，都是通过微信客户端进行转发。小程序启动运行两种情况：冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动<br>热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动。</li></ul><h3 id="二、小程序的登录流程"><a href="#二、小程序的登录流程" class="headerlink" title="二、小程序的登录流程"></a>二、小程序的登录流程</h3><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">小程序登录说明官方链接</a></p></blockquote><h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h4><ul><li>传统web开发实现登录功能<ul><li>传统的web开发实现登陆功能，一般的做法是输入账号密码、或者输入手机号及短信验证码进行登录；服务端校验用户信息通过之后，下发一个代表登录态的 token 给客户端，以便进行后续的交互,每当token过期，用户都需要重新登录</li></ul></li><li>小程序实现登录功能<ul><li>而在微信小程序中，可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系，从而实现登陆功能；实现小程序用户体系主要涉及到openid和code的概念：用<strong>wx.login()<strong>方法会生成code，将code作为参数传递给微信服务器指定接口，就可以获取用户的</strong>openid</strong>。对于每个小程序，微信都会将用户的微信ID映射出一个小程序 openid，作为这个用户在这个小程序的唯一标识</li></ul></li></ul><h4 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程"></a>2.流程</h4><ol><li><p>通过 wx.login() 获取到用户的code判断用户是否授权读取用户信息，调用wx.getUserInfo 读取用户数据</p></li><li><p>由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息</p></li><li><p>通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到</p></li><li><p>微信服务器返回了 openid 及本次登录的会话密钥 session_key</p></li><li><p>后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走</p></li><li><p>session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输</p></li><li><p>然后生成 session并返回给小程序</p></li><li><p>小程序把 session 存到 storage 里面</p></li><li><p>下次请求时，先从 storage 里面读取，然后带给服务端</p></li><li><p>服务端对比 session 对应的记录，然后校验有效期</p><img src="/2022/06/25/xiao-cheng-xu-shi-xian-yu-deng-lu/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png" style="zoom:80%;"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序生命周期</title>
      <link href="/2022/06/24/xiao-cheng-xu-sheng-ming-zhou-qi/"/>
      <url>/2022/06/24/xiao-cheng-xu-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h3><h4 id="1-应用的生命周期"><a href="#1-应用的生命周期" class="headerlink" title="1.应用的生命周期"></a>1.应用的生命周期</h4><ul><li><p>概念：特指小程序从启动–&gt;运行–&gt;销毁的过程。</p></li><li><p>在<strong>app.js</strong>中进行声明。</p></li><li><p>常见的应用生命周期函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// app.js文件</span><span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment">// 小程序初始化完成时，执行此函数，全局只触发一次，可以做一些初始化工作</span>  <span class="token function-variable function">onLaunch</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 小程序启动，或从后台进入前台显示时触发</span>  <span class="token function-variable function">onShow</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 小程序从前台进入后台时触发</span>  <span class="token function-variable function">onHide</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="2-页面的生命周期"><a href="#2-页面的生命周期" class="headerlink" title="2.页面的生命周期"></a>2.页面的生命周期</h4><ul><li><p>概念：特指小程序中，每个页面的加载–&gt;渲染–&gt;销毁的过程。</p></li><li><p>在<strong>页面对应的.js</strong>中声明。</p></li><li><p>常见的应用生命周期函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 页面的.js文件</span><span class="token function">Page</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment">// 监听页面加载，一个页面只调用一次</span>  <span class="token function-variable function">onLoad</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 监听页面显示</span>  <span class="token function-variable function">onShow</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 监听页面初次渲染完成，一个页面只调用一次</span>  <span class="token function-variable function">onReady</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 监听页面隐藏</span>  <span class="token function-variable function">onHide</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 监听页面卸载，一个页面只调用一次</span>  <span class="token function-variable function">onUnload</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="3-组件的生命周期"><a href="#3-组件的生命周期" class="headerlink" title="3.组件的生命周期"></a>3.组件的生命周期</h4><table><thead><tr><th align="center">生命周期函数</th><th align="center">参数</th><th align="center">描述说明</th></tr></thead><tbody><tr><td align="center"><strong>created</strong></td><td align="center"><strong>无</strong></td><td align="center"><strong>在组件实例刚刚被创建时执行</strong></td></tr><tr><td align="center"><strong>attached</strong></td><td align="center"><strong>无</strong></td><td align="center"><strong>在组件实例进入页面节点树时执行</strong></td></tr><tr><td align="center">ready</td><td align="center">无</td><td align="center">在组件在视图层布局完成后执行</td></tr><tr><td align="center">moved</td><td align="center">无</td><td align="center">在组件实例被移到到节点树另一个位置时执行</td></tr><tr><td align="center"><strong>detached</strong></td><td align="center"><strong>无</strong></td><td align="center"><strong>在组件实例被从页面节点树移除时执行</strong></td></tr><tr><td align="center">error</td><td align="center">Object Error</td><td align="center">每当组件方法抛出错误时执行</td></tr></tbody></table><h3 id="二、生命周期函数"><a href="#二、生命周期函数" class="headerlink" title="二、生命周期函数"></a>二、生命周期函数</h3><h4 id="1-应用的生命周期函数"><a href="#1-应用的生命周期函数" class="headerlink" title="1.应用的生命周期函数"></a>1.应用的生命周期函数</h4><ul><li><p>小程序的生命周期函数是在app.js里面调用的，通过App(Object)函数用来注册一个小程序，指定其小程序的生命周期回调。</p><table><thead><tr><th align="center">生命周期函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">onLaunch</td><td align="center">小程序初始化完成时触发，全局只触发一次</td></tr><tr><td align="center">onShow</td><td align="center">小程序启动，或从后台进入前台显示时触发</td></tr><tr><td align="center">onHide</td><td align="center">小程序从前台进入后台时触发</td></tr><tr><td align="center">onError</td><td align="center">小程序发生脚本错误或API调用报错时触发</td></tr><tr><td align="center">onPageNotFound</td><td align="center">小程序要打开的页面不存在时触发</td></tr><tr><td align="center">onUnhandledRejection()</td><td align="center">小程序有未处理的Promise拒绝时触发</td></tr><tr><td align="center">onThemeChange</td><td align="center">系统切换主题时触发</td></tr></tbody></table></li></ul><h4 id="2-页面的生命周期函数"><a href="#2-页面的生命周期函数" class="headerlink" title="2.页面的生命周期函数"></a>2.页面的生命周期函数</h4><ul><li><p>页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数，通过page(Object)函数用来注册一个页面。</p><table><thead><tr><th align="center">生命周期函数</th><th align="center">说明</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">onLoad</td><td align="center">监听页面加载</td><td align="center">发送请求获取数据</td></tr><tr><td align="center">onShow</td><td align="center">监听页面显示</td><td align="center">请求数据</td></tr><tr><td align="center">onReady</td><td align="center">监听页面初次渲染完成</td><td align="center">获取页面元素(少用)</td></tr><tr><td align="center">onHide</td><td align="center">监听页面隐藏</td><td align="center">终止任务，如定时器或播放音乐</td></tr><tr><td align="center">onUnload</td><td align="center">监听页面卸载</td><td align="center">终止任务</td></tr></tbody></table></li></ul><h4 id="3-组件的生命周期函数"><a href="#3-组件的生命周期函数" class="headerlink" title="3.组件的生命周期函数"></a>3.组件的生命周期函数</h4><ul><li>组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发，通过Component(Object)进行注册组件。<ul><li>组件实例刚刚被创建好时，created生命周期被触发，此时，组件数据 this.data 就是在Component构造器中定义的数据data， 此时不能调用setData。</li><li>在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。</li><li>在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则detached会被触发。</li></ul></li></ul><table><thead><tr><th align="center">生命周期函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>created</strong></td><td align="center"><strong>监听页面加载</strong></td></tr><tr><td align="center"><strong>attached</strong></td><td align="center"><strong>监听页面显示</strong></td></tr><tr><td align="center">ready</td><td align="center">监听页面初次渲染完成</td></tr><tr><td align="center">moved</td><td align="center">监听页面隐藏</td></tr><tr><td align="center"><strong>detached</strong></td><td align="center"><strong>监听页面卸载</strong></td></tr><tr><td align="center">error</td><td align="center">每当组件方法抛出错误时执行</td></tr></tbody></table><ul><li><p>组件中特殊的生命周期函数</p><ul><li><p>还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理，这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。</p><table><thead><tr><th align="center">生命周期函数</th><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">show</td><td align="center">无</td><td align="center"><strong>组件所在的页面</strong>被展示时执行</td></tr><tr><td align="center">hide</td><td align="center">无</td><td align="center"><strong>组件所在的页面</strong>被隐藏时执行</td></tr><tr><td align="center">resize</td><td align="center">Object Size</td><td align="center"><strong>组件所在的页面</strong>尺寸变化时执行</td></tr></tbody></table></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flexbox Froggy小游戏</title>
      <link href="/2022/06/23/flexbox-froggy-xiao-you-xi/"/>
      <url>/2022/06/23/flexbox-froggy-xiao-you-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Flex布局"><a href="#一、Flex布局" class="headerlink" title="一、Flex布局"></a>一、Flex布局</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。即弹性盒子布局，可以解决元素居中问题，和自动弹性伸缩，合适适配不同大小的屏幕/移动端。</p><table><thead><tr><th align="center">父项属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">flex-direction</td><td align="center">设置主轴方向</td></tr><tr><td align="center">flex-wrap</td><td align="center">设置子元素是否换行</td></tr><tr><td align="center">flex-flow</td><td align="center">复合属性，相当于同时设置了flex-direction和flex-wrap</td></tr><tr><td align="center">justify-content</td><td align="center">设置主轴上的子元素排列方式</td></tr><tr><td align="center">align-content</td><td align="center">设置侧轴上的子元素排列方式(多行)</td></tr><tr><td align="center">align-items</td><td align="center">设置侧轴上的子元素排列方式(单行)</td></tr></tbody></table><table><thead><tr><th align="center">子项属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">flex</td><td align="center">子项目占的份数，可以是百分数</td></tr><tr><td align="center">align-self</td><td align="center">控制子项自己在侧轴的排列方式</td></tr><tr><td align="center">order</td><td align="center">定义子项的排列前后顺序，默认是0，数值越小，排列越靠前</td></tr></tbody></table><ol><li><p><strong>父项属性</strong></p><ul><li><strong>flex-direction</strong><ul><li>row(默认值)：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul></li><li><strong>flex-wrap</strong><ul><li>nowrap(默认值)：不换行压缩宽度</li><li>wrap：换行</li><li>wrap-reverses：反向换行</li></ul></li><li><strong>flex-flow</strong><ul><li>flex-low：[flex-direction] [flex-wrap]</li></ul></li><li><strong>justify-content</strong><ul><li>flex-start(默认值)：靠着main-start对齐//参考常见术语(一般是左方向)</li><li>flex-end：靠着main-end对齐//参考常见术语(一般是右方向)</li><li>center：靠着主轴居中对齐//一般就是居中对齐</li><li>space-between：两端对齐，靠着容器壁，剩余空间平分</li><li>space-around：分散对齐，不靠着容器壁，剩余空间在每个项目二侧平均分配</li><li>space-evenly：平均对齐，不靠着容器壁，剩余空间平分</li></ul></li><li><strong>align-content</strong><ul><li>flex-start：(每一行)(默认)靠着cross-start对齐//参考常见术语(一般是左方向)</li><li>flex-end：（每一行)靠着cross-end对齐//参考常见术语(一般是右方向)</li><li>center： (每一行)靠着cross线居中对齐//一般就是居中对齐</li><li>space-between：(每一行)两端对齐，靠着容器上下壁，剩余空间平分</li><li>space-around：(每一行)分散对齐，不靠着容器壁，剩余空间在每个项目二侧平均分配</li><li>strentch：(每一行)伸缩，占满整个高度</li></ul></li><li><strong>align-items</strong><ul><li>flex-start：交叉轴的起点对齐</li><li>flex-end：交叉轴的终点对齐</li><li>center：交叉轴的中点对齐</li><li>baseline：项目的第一行文字的基线对齐</li><li>stretch(默认值)伸展：如果项目未设置高度或设为auto，将占满整个容器的高度</li></ul></li></ul></li><li><p><strong>子项属性</strong></p><ul><li><p><strong>flex</strong></p></li><li><p><strong>align-self</strong></p><ul><li><p>auto(默认值)：继承 <code>align-items</code> 属性值</p></li><li><p>flex-start：与交叉轴起始线对齐</p></li><li><p>flex-end：与交叉轴终止线对齐</p></li><li><p>center：与交叉轴中间线对齐: 居中对齐</p></li><li><p>baseline：项目的第一行文字的基线对齐</p></li><li><p>stretch：在交叉轴方向上拉伸</p></li></ul></li><li><p><strong>order</strong></p></li></ul></li></ol><h3 id="二、Flexbox-Froggy小游戏"><a href="#二、Flexbox-Froggy小游戏" class="headerlink" title="二、Flexbox Froggy小游戏"></a>二、Flexbox Froggy小游戏</h3><blockquote><p><strong>官网链接</strong>：<a href="http://flexboxfroggy.com/">一个学习 CSS flexbox 的游戏</a></p></blockquote><h4 id="1-第一关"><a href="#1-第一关" class="headerlink" title="1.第一关"></a>1.第一关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">justify-content</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-第二关"><a href="#2-第二关" class="headerlink" title="2.第二关"></a>2.第二关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-第三关"><a href="#3-第三关" class="headerlink" title="3.第三关"></a>3.第三关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">justify-content</span><span class="token punctuation">:</span> space-around<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-第四关"><a href="#4-第四关" class="headerlink" title="4,第四关"></a>4,第四关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">justify-content</span><span class="token punctuation">:</span> space-between<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-第五关"><a href="#5-第五关" class="headerlink" title="5.第五关"></a>5.第五关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">align-items</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-第六关"><a href="#6-第六关" class="headerlink" title="6.第六关"></a>6.第六关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="7-第七关"><a href="#7-第七关" class="headerlink" title="7.第七关"></a>7.第七关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">justify-content</span><span class="token punctuation">:</span> space-around<span class="token punctuation">;</span><span class="token property">align-items</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="8-第八关"><a href="#8-第八关" class="headerlink" title="8.第八关"></a>8.第八关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">flex-direction</span><span class="token punctuation">:</span> row-reverse<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="9-第九关"><a href="#9-第九关" class="headerlink" title="9.第九关"></a>9.第九关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="10-第十关"><a href="#10-第十关" class="headerlink" title="10.第十关"></a>10.第十关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">flex-direction</span><span class="token punctuation">:</span> row-reverse<span class="token punctuation">;</span><span class="token property">justify-content</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="11-第十一关"><a href="#11-第十一关" class="headerlink" title="11.第十一关"></a>11.第十一关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span><span class="token property">justify-content</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="12-第十二关"><a href="#12-第十二关" class="headerlink" title="12.第十二关"></a>12.第十二关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">flex-direction</span><span class="token punctuation">:</span> column-reverse<span class="token punctuation">;</span><span class="token property">justify-content</span><span class="token punctuation">:</span> space-between<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="13-第十三关"><a href="#13-第十三关" class="headerlink" title="13.第十三关"></a>13.第十三关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">flex-direction</span><span class="token punctuation">:</span> row-reverse<span class="token punctuation">;</span><span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token property">align-items</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="14-第十四关"><a href="#14-第十四关" class="headerlink" title="14.第十四关"></a>14.第十四关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">order</span><span class="token punctuation">:</span> 2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="15-第十五关"><a href="#15-第十五关" class="headerlink" title="15.第十五关"></a>15.第十五关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">order</span><span class="token punctuation">:</span> -1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="16-第十六关"><a href="#16-第十六关" class="headerlink" title="16.第十六关"></a>16.第十六关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">align-self</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="17-第十七关"><a href="#17-第十七关" class="headerlink" title="17.第十七关"></a>17.第十七关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">order</span><span class="token punctuation">:</span> 2<span class="token punctuation">;</span><span class="token property">align-self</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="18-第十八关"><a href="#18-第十八关" class="headerlink" title="18.第十八关"></a>18.第十八关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">flex-wrap</span><span class="token punctuation">:</span> wrap<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="19-第十九关"><a href="#19-第十九关" class="headerlink" title="19.第十九关"></a>19.第十九关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">flex-wrap</span><span class="token punctuation">:</span> wrap<span class="token punctuation">;</span><span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="20-第二十关"><a href="#20-第二十关" class="headerlink" title="20.第二十关"></a>20.第二十关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">flex-flow</span><span class="token punctuation">:</span> column wrap<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="21-第二十一关"><a href="#21-第二十一关" class="headerlink" title="21.第二十一关"></a>21.第二十一关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">align-content</span><span class="token punctuation">:</span> flex-start<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="22-第二十二关"><a href="#22-第二十二关" class="headerlink" title="22.第二十二关"></a>22.第二十二关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">align-content</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="23-第二十三关"><a href="#23-第二十三关" class="headerlink" title="23.第二十三关"></a>23.第二十三关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">flex-direction</span><span class="token punctuation">:</span> column-reverse<span class="token punctuation">;</span><span class="token property">align-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="24-第二十四关"><a href="#24-第二十四关" class="headerlink" title="24.第二十四关"></a>24.第二十四关</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">flex-flow</span><span class="token punctuation">:</span> wrap-reverse column-reverse<span class="token punctuation">;</span><span class="token property">align-content</span><span class="token punctuation">:</span> space-between<span class="token punctuation">;</span><span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="三、通关Success！！！"><a href="#三、通关Success！！！" class="headerlink" title="三、通关Success！！！"></a>三、通关Success！！！</h3><img src="/2022/06/23/flexbox-froggy-xiao-you-xi/Flex.png" style="zoom:60%;"><h3 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h3><blockquote><p>CSS样式练习官网链接： <a href="https://cssbattle.dev/">CSSBattle在线比拼</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试心得二</title>
      <link href="/2022/06/17/mian-shi-xin-de-er/"/>
      <url>/2022/06/17/mian-shi-xin-de-er/</url>
      
        <content type="html"><![CDATA[<ul><li>###########################</li><li>###########################</li><li>###########################</li><li>###########################</li><li>###########################</li><li>###########################</li><li>###########################</li></ul><h4 id="一、面试时间地点"><a href="#一、面试时间地点" class="headerlink" title="一、面试时间地点"></a>一、面试时间地点</h4><blockquote><p>2022年6月17日     在成都市郫都区龙湖成都时代天街17栋17楼1718-触及科技     笔试通过</p></blockquote><h4 id="二、笔试问题归纳"><a href="#二、笔试问题归纳" class="headerlink" title="二、笔试问题归纳"></a>二、笔试问题归纳</h4><ol><li>content-box和border-box计算盒子的宽高？</li><li>CSS样式权重问题，判断其颜色？</li><li>true和false的动态计算判断？</li><li>用CSS实现一个直角三角形？</li><li>使用addEventListener()为li元素绑定事件，输出点击li元素的输出顺序？</li><li>同步任务和异步任务结合的分析执行顺序？</li><li>宏任务和微任务结合分析其执行顺序？</li><li>宏任务、微任务、同步任务和异步任务结合分析其执行顺序？</li><li>apply()、call()和bind()、箭头函数结合判断this指向问题？</li><li>手写封装一个函数，实现数组元素升序排序和去重两个功能？</li><li>行内元素？块级元素？行内块元素？块级元素和行内块元素的区别？</li></ol><h4 id="三、面试总结"><a href="#三、面试总结" class="headerlink" title="三、面试总结"></a>三、面试总结</h4><ul><li>笔试面试通过</li></ul>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试心得(一)</title>
      <link href="/2022/06/07/mian-shi-xin-de-yi/"/>
      <url>/2022/06/07/mian-shi-xin-de-yi/</url>
      
        <content type="html"><![CDATA[<ul><li>###########################</li><li>###########################</li><li>###########################</li><li>###########################</li><li>###########################</li><li>###########################</li><li>###########################</li></ul><h4 id="一、面试时间地点"><a href="#一、面试时间地点" class="headerlink" title="一、面试时间地点"></a>一、面试时间地点</h4><blockquote><p>2022年6月7日     在绵阳临园商务大夏进行第一次找实习的前端面试</p></blockquote><h4 id="二、面试问题归纳"><a href="#二、面试问题归纳" class="headerlink" title="二、面试问题归纳"></a>二、面试问题归纳</h4><ol><li>首先自我介绍</li><li>会Vue吗？会React吗？</li><li>Vue常见的指令？</li><li>Vue组件间的通信方式？</li><li>Vue-router路由的两种模式及区别？</li><li>ES6新增了哪些语法？</li><li>简述一下Promise？</li><li>async/await的使用场景方法？</li><li>GET和POST请求方式的区别？</li><li>WebSocket是什么及它的原理？</li><li>讲一下JavaScript的面向对象编程？</li></ol><h4 id="三、面试总结"><a href="#三、面试总结" class="headerlink" title="三、面试总结"></a>三、面试总结</h4><ul><li>面试易紧张</li><li>部分回答的描述不规范</li><li>面试易紧张有些知识点知道，但描述不出来，需巩固加强</li><li>不清楚JS的面向对象编程和WebSocket原理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目优化打包部署</title>
      <link href="/2022/06/02/xiang-mu-you-hua-da-bao-bu-shu/"/>
      <url>/2022/06/02/xiang-mu-you-hua-da-bao-bu-shu/</url>
      
        <content type="html"><![CDATA[<h4 id="一、项目优化"><a href="#一、项目优化" class="headerlink" title="一、项目优化"></a>一、项目优化</h4><h5 id="1-去掉打印console"><a href="#1-去掉打印console" class="headerlink" title="1.去掉打印console"></a>1.去掉打印console</h5><ul><li><p>需求：在开发环境中，保留打印console；在生产上线环境，自动去掉打印console</p></li><li><p>使用步骤：</p><ul><li><p><strong>第一步：在项目根目录下，创建如下图两个配置文件</strong></p><img src="/2022/06/02/xiang-mu-you-hua-da-bao-bu-shu/%E5%8E%BB%E6%8E%89%E6%89%93%E5%8D%B0.png" style="zoom:60%;"><blockquote><p>在.env.development中(开发环境变量)</p></blockquote><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">NODE_ENV=development<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在.env.production中(生产上线环境变量)</p></blockquote><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">NODE_ENV=production<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>第二步：在main.js中添加配置</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'development'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// process是Node环境全部变量, 运行时根据敲击的命令不同, 脚手架会取环境变量给env添加属性和值</span>  console<span class="token punctuation">.</span><span class="token function-variable function">log</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  console<span class="token punctuation">.</span><span class="token function-variable function">error</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  console<span class="token punctuation">.</span><span class="token function-variable function">dir</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h5 id="2-解决依赖包大的问题"><a href="#2-解决依赖包大的问题" class="headerlink" title="2.解决依赖包大的问题"></a>2.解决依赖包大的问题</h5><ul><li>默认情况下，通过import语法导入的第三方依赖包，最终会被打包合并到同一个文件中，从而导致打包成功后，单文件体积过大的问题。</li><li><strong>解决方案：通过externals加载外部CDN资源</strong>。凡是声明在externals中的第三方依赖包，都不会被打包。</li><li><strong>在public/index.html文件的头部，添加对应的CDN资源引用</strong>。</li></ul><h4 id="二、项目打包"><a href="#二、项目打包" class="headerlink" title="二、项目打包"></a>二、项目打包</h4><h5 id="1-项目配置"><a href="#1-项目配置" class="headerlink" title="1.项目配置"></a>1.项目配置</h5><ul><li><p>详见：<a href="https://www.webpackjs.com/concepts/">webpack中文网</a></p></li><li><p>在项目根目录下，创建vue.config.js文件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 打包后的基本路径</span>  <span class="token literal-property property">publicPath</span><span class="token operator">:</span> <span class="token string">'./'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="三、项目部署"><a href="#三、项目部署" class="headerlink" title="三、项目部署"></a>三、项目部署</h4><h5 id="1-本地服务器"><a href="#1-本地服务器" class="headerlink" title="1.本地服务器"></a>1.本地服务器</h5><ul><li><p>通过node创建web服务器</p></li><li><p>并开启gzip配置，以减少文件体积，使传输速度更快</p><ul><li><blockquote><p>npm install compression -D</p></blockquote></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 创建node项目，并安装express，通过express快速创建web服务器，将vue打包生产的dist文件夹，托管为静态资源，并开启gzip配置，以减少文件体积，使传输速度更快</span><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token keyword">const</span> compression <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'compression'</span><span class="token punctuation">)</span><span class="token comment">// 创建web服务器</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 启用中间件</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">compression</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 托管静态资源</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token function">static</span><span class="token punctuation">(</span><span class="token string">'./dist'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 启动web服务器</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器已成功启动'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="2-远程服务器"><a href="#2-远程服务器" class="headerlink" title="2.远程服务器"></a>2.远程服务器</h5>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器本地存储</title>
      <link href="/2022/05/27/liu-lan-qi-ben-di-cun-chu/"/>
      <url>/2022/05/27/liu-lan-qi-ben-di-cun-chu/</url>
      
        <content type="html"><![CDATA[<h4 id="一、浏览器本地存储方式及使用场景"><a href="#一、浏览器本地存储方式及使用场景" class="headerlink" title="一、浏览器本地存储方式及使用场景"></a>一、浏览器本地存储方式及使用场景</h4><h5 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1.Cookie"></a>1.Cookie</h5><ul><li><p>概念：Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。</p></li><li><p>特性：</p><ul><li>Cookie一旦创建成功，名称就无法修改</li><li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li><li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li><li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li><li>Cookie在请求一个新的页面的时候都会被发送过去</li></ul></li><li><p>使用场景：</p><ul><li>最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。（cookie与session都可用于身份认证）</li><li>可以用来统计页面的点击次数</li></ul></li><li><p>Cookie的字段及作用：</p><ul><li><p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问</p></li><li><p>Name：cookie的名称</p></li><li><p>Value：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌</p></li><li><p>Size： cookie的大小</p></li><li><p>Path：可以访问此cookie的页面路径。 比如domain是abc.com，path是/test，那么只有/test路径下的页面可以读取此cookie。</p></li><li><p>Secure： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点</p></li><li><p>Domain：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围</p></li><li><p>HTTP： 该字段包含HTTPOnly 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头</p></li><li><p>Expires/Max-size ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效</p></li></ul></li></ul><h5 id="2-LocalStorage"><a href="#2-LocalStorage" class="headerlink" title="2.LocalStorage"></a>2.LocalStorage</h5><ul><li><p>概念：LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。永久存储，不会随着刷新页面或者关闭页面而消失。</p></li><li><p>优点：</p><ul><li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li><li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li><li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li></ul></li><li><p>缺点：</p><ul><li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li><li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li><li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li></ul></li><li><p>使用场景：</p><ul><li>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</li><li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li></ul></li><li><p>常用API</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 保存数据到localStorage</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span><span class="token comment">// 从localStorage中获取数据</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token comment">// 从localStorage中删除某一数据</span>localStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token comment">// 从localStorage删除所有数据</span>localStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="3-SessionStorage"><a href="#3-SessionStorage" class="headerlink" title="3.SessionStorage"></a>3.SessionStorage</h5><ul><li><p>概念：SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p></li><li><p>与LocalStorage对比：</p><ul><li>SessionStorage和LocalStorage都在本地进行数据存储</li><li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage只有在同一浏览器的同一窗口下才能够共享</li><li>LocalStorage和SessionStorage都不能被爬虫爬取</li></ul></li><li><p>使用场景：</p><ul><li>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了</li></ul></li><li><p>常用API</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 保存数据到sessionStorage</span>sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span><span class="token comment">// 从sessionStorage中获取数据</span>sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token comment">// 从sessionStorage中删除某一数据</span>sessionStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token comment">// 从sessionStorage删除所有数据</span>sessionStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器同源策略</title>
      <link href="/2022/05/27/liu-lan-qi-tong-yuan-ce-lue/"/>
      <url>/2022/05/27/liu-lan-qi-tong-yuan-ce-lue/</url>
      
        <content type="html"><![CDATA[<h4 id="一、同源政策"><a href="#一、同源政策" class="headerlink" title="一、同源政策"></a>一、同源政策</h4><ul><li>跨域问题其实就是浏览器的同源策略造成的。同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：协议、端口号、域名必须一致。同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。同源政策主要限制了三个方面。<ul><li>当前域下的 js 脚本不能够访问其他域下的 cookie、LocalStorage、SessionStorage 和 indexDB。</li><li>当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li><li>当前域下 ajax 无法发送跨域请求。</li></ul></li></ul><h4 id="二、解决跨域问题方法"><a href="#二、解决跨域问题方法" class="headerlink" title="二、解决跨域问题方法"></a>二、解决跨域问题方法</h4><h5 id="1-CORS"><a href="#1-CORS" class="headerlink" title="1.CORS"></a>1.CORS</h5><ul><li>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现CORS的关键就是服务器，只要服务器实现了CORS请求，就可以跨源通信了。</li></ul><h5 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2.JSONP"></a>2.JSONP</h5><ul><li>jsonp的原理就是利用script标签没有跨域限制，通过script标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</li><li>缺点：具有局限性， 仅支持get方法；不安全，可能会遭受XSS攻击。</li></ul><h5 id="3-postMessage跨域"><a href="#3-postMessage跨域" class="headerlink" title="3.postMessage跨域"></a>3.postMessage跨域</h5><ul><li>解决问题：<ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul></li><li>用法：<ul><li>postMessage(data,origin)方法接受两个参数</li><li>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li><li>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li></ul></li></ul><h5 id="4-nginx代理跨域"><a href="#4-nginx代理跨域" class="headerlink" title="4.nginx代理跨域"></a>4.nginx代理跨域</h5><ul><li><p>Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。</p></li><li><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p></li><li><p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p></li></ul><h5 id="5-nodejs中间件代理跨域"><a href="#5-nodejs中间件代理跨域" class="headerlink" title="5.nodejs中间件代理跨域"></a>5.nodejs中间件代理跨域</h5><ul><li>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</li></ul><h5 id="6-document-domain-iframe跨域"><a href="#6-document-domain-iframe跨域" class="headerlink" title="6.document.domain + iframe跨域"></a>6.document.domain + iframe跨域</h5><ul><li>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</li></ul><h5 id="7-location-hash-iframe跨域"><a href="#7-location-hash-iframe跨域" class="headerlink" title="7.location.hash + iframe跨域"></a>7.location.hash + iframe跨域</h5><ul><li>实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</li></ul><h5 id="8-window-name-iframe跨域"><a href="#8-window-name-iframe跨域" class="headerlink" title="8.window.name + iframe跨域"></a>8.window.name + iframe跨域</h5><h5 id="9-WebSocket协议跨域"><a href="#9-WebSocket协议跨域" class="headerlink" title="9.WebSocket协议跨域"></a>9.WebSocket协议跨域</h5><ul><li>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</li></ul><h4 id="三、正向代理与反向代理的区别"><a href="#三、正向代理与反向代理的区别" class="headerlink" title="三、正向代理与反向代理的区别"></a>三、正向代理与反向代理的区别</h4><ul><li><p>正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。</p></li><li><p><strong>正向代理</strong>：</p><ul><li><p>客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。</p><img src="/2022/05/27/liu-lan-qi-tong-yuan-ce-lue/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" style="zoom:60%;"></li></ul></li><li><p><strong>反向代理</strong>：</p><ul><li><p>服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。</p><img src="/2022/05/27/liu-lan-qi-tong-yuan-ce-lue/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" style="zoom:60%;"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本管理</title>
      <link href="/2022/05/27/ban-ben-guan-li/"/>
      <url>/2022/05/27/ban-ben-guan-li/</url>
      
        <content type="html"><![CDATA[<h4 id="一、前端工程化"><a href="#一、前端工程化" class="headerlink" title="一、前端工程化"></a>一、前端工程化</h4><ul><li>概念：前端工程化是指：在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。</li></ul><h4 id="二、版本管理"><a href="#二、版本管理" class="headerlink" title="二、版本管理"></a>二、版本管理</h4><ul><li><p>概念：版本控制是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一程序文件都得到同步。</p></li><li><p>分类：本地版本控制系统、集中式版本控制系统、分布式版本控制系统。</p><ul><li><p><strong>本地版本控制系统</strong></p><ul><li><p>优点：简单，很多系统中都有内置；适合管理文本，如系统配置。</p></li><li><p>缺点：其不支持远程操作，因此并不适合多人版本开发。</p><img src="/2022/05/27/ban-ben-guan-li/%E6%9C%AC%E5%9C%B0%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.png" style="zoom:60%;"></li></ul></li><li><p><strong>集中式版本控制系统</strong></p><ul><li><p>优点：适合多人团队协作开发；代码集中化管理。</p></li><li><p>缺点：单点故障；必须联网，无法单机工作。</p></li><li><p>代表工具：SVN、CVS。</p><img src="/2022/05/27/ban-ben-guan-li/%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.png" style="zoom:60%;"></li></ul></li><li><p><strong>分布式版本控制系统</strong></p><ul><li><p>分布式版本管理系统每个计算机都有一个完整的仓库，可本地提交，可以做到离线工作，则不用像集中管理那样因为断网情况而无法工作。</p></li><li><p>优点：适合多人团队协作开发；代码集中化管理；可以离线工作；每个计算机都是一个完整仓库。</p><img src="/2022/05/27/ban-ben-guan-li/%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.png" style="zoom:60%;"></li><li><p>代表工具：<strong>Git</strong></p><ul><li><p><strong>git常用命令</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 新建初始化git代码仓库<span class="token function">git</span> init// 创建并切换到当前分支<span class="token function">git</span> checkout -b xxx// 查看文件变更状态<span class="token function">git</span> status// 将本地修改的文件添加至暂存区<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>// 提交暂存区文件至仓库区<span class="token function">git</span> commit -m <span class="token string">"备注提交的信息"</span>// 将分支推送至远程仓库<span class="token function">git</span> push -u origin xxx// 查看所有分支<span class="token function">git</span> branch// 切换到某一分支<span class="token function">git</span> checkout xxx// 合并到目前分支<span class="token function">git</span> merge xxx// 删除本地下的某一分支<span class="token function">git</span> branch -d xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>git pull 和 git fetch 的区别</p><ul><li>git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。</li><li>git pull 会将远程仓库的变化下载下来，并和当前分支合并。</li></ul></li><li><p>git rebase 和 git merge 的区别</p><ul><li>git merge 和 git rebase 都是用于分支合并，关键在 commit 记录的处理上不同。</li><li>git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。</li><li>git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。</li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2022/05/26/vuex/"/>
      <url>/2022/05/26/vuex/</url>
      
        <content type="html"><![CDATA[<h4 id="一、Vuex的概述"><a href="#一、Vuex的概述" class="headerlink" title="一、Vuex的概述"></a>一、Vuex的概述</h4><ul><li><p>概念：专门在 Vue 中实现集中式<strong>状态（数据）管理</strong>的一个 Vue 插件，对 vue 应 用中多个组件的共享状态进行集中式的管理（读/写），也是一种<strong>组件间通信</strong>的方 式，且适用于任意组件间通信。</p></li><li><p>Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。</p><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。</li></ul></li><li><p><strong>原理</strong>如图所示：</p><img src="/2022/05/26/vuex/Vuex.png" style="zoom:60%;"></li></ul><h4 id="二、Vuex的构造"><a href="#二、Vuex的构造" class="headerlink" title="二、Vuex的构造"></a>二、Vuex的构造</h4><h5 id="1-actions"><a href="#1-actions" class="headerlink" title="1.actions"></a>1.actions</h5><ul><li>由子组件this.$store.dispatch(‘actions名’,传递的数据）触发</li><li>传递的数据只能是单个数据，多个数据用对象传递</li><li>actions： { action名（{commit}，数据）{…}}</li><li>store中actions内，commit用于触发mutations，actions只做业务逻辑，不修改state</li></ul><h5 id="2-mutations"><a href="#2-mutations" class="headerlink" title="2.mutations"></a>2.mutations</h5><ul><li>由actions中的commit(‘mutations名’,传递的数据）触发</li><li>mutations：{mutations名（state,数据）{…}}</li><li>store中的mutations内，mutations可以修改state中的数据</li></ul><h5 id="3-state"><a href="#3-state" class="headerlink" title="3.state"></a>3.state</h5><ul><li>存储数据：state：{userInfor：{}}</li><li>可以通过mutations存储或者修改，也是getters里面计算属性的依据</li></ul><h5 id="4-getters"><a href="#4-getters" class="headerlink" title="4.getters"></a>4.getters</h5><ul><li>计算state中的数据：getters：{getters名（state）{…}}</li><li>state用于getters计算属性的依据</li></ul><h4 id="三、Vuex中的模块-module-和命名空间-namespaced"><a href="#三、Vuex中的模块-module-和命名空间-namespaced" class="headerlink" title="三、Vuex中的模块(module)和命名空间(namespaced)"></a>三、Vuex中的模块(module)和命名空间(namespaced)</h4><h5 id="1-模块-module"><a href="#1-模块-module" class="headerlink" title="1.模块(module)"></a>1.模块(module)</h5><ul><li>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。<br>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的state、mutations、actions、getters、甚至是嵌套子模块。</li></ul><h5 id="2-命名空间-namespaced"><a href="#2-命名空间-namespaced" class="headerlink" title="2.命名空间(namespaced)"></a>2.命名空间(namespaced)</h5><ul><li><p>默认情况下，模块内部的 actions、mutations 和 getters 是注册在全局命名空间的——这样使得多个模块能够对同一 mutations 或 actions 作出响应，如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getters、actions 及 mutations 都会自动根据模块注册的路径调整命名。</p></li><li><p>如果你想模块之间相互独立、互不影响。可以通过添加 namespaced: true 的方式使其成为带命名空间的模块，当模块被注册后，它的所有 getters、actions 和 mutations 都会自动根据模块注册的路径调整命名。所以开启命名空间的模块中的getters、actions 和 mutations的使用方式都会改变；但是开启命名空间和不开启命名空间的模块中的state的使用方式不会改变。格式依然是store.state.模块名.状态名。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 开启store子模块的命名空间</span><span class="token keyword">const</span> moduleName <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token literal-property property">getters</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token literal-property property">namespaced</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token comment">// 开启命名空间</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> moduleName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">// 在组件中使用import { mapState, mapGetters, mapActions } from 'vuex'export default {computed: {// 传统方式：获取store中的数据proData () {return this.$store.state.productModule.proData},themeData () {return this.$store.getters['themeModule/themeData']},proName () {return this.$store.getters['productModule/proName']},proDesc () {return this.$store.getters['productModule/proDesc']},indexData () {return this.$store.getters['productModule/indexData']}// 辅助函数方式一：获取store中的数据(代码较简洁)...mapState({ proData: state =&gt; state.productModule.proData })...mapGetters(['themeModule/themeData'])...mapGetters(['themeModule/proName', 'themeModule/proDesc', 'themeModule/indexData'])// 辅助函数方式二：获取store中的数据(代码最简洁)...mapState('productModule', { proData: state =&gt; state.proData })...mapGetters('themeModule', ['themeData'])...mapGetters('productModule', ['proName', 'proDesc', 'indexData'])},created () {// 传统方式：获取异步数据this.$store.dispath('themeModule/queryThemeAction')this.$store.dispath('productModule/queryProDataAction')this.$store.dispath('productModule/queryIndexDataAction')// 辅助函数方式：获取异步数据(需要在methods中使用mapActions定义方法)this.queryThemeAction()this.queryProDataAction()this.queryIndexDataAction()},methods: {...mapActions('themeModule', ['queryThemeAction'])...mapActions('productModule', ['queryProDataAction', 'queryIndexDataAction'])}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6</title>
      <link href="/2022/05/25/es6/"/>
      <url>/2022/05/25/es6/</url>
      
        <content type="html"><![CDATA[<h4 id="一、ES6概述"><a href="#一、ES6概述" class="headerlink" title="一、ES6概述"></a>一、ES6概述</h4><ul><li>新增了变量的声明方式、解构赋值、模板字符串、简化对象写法、箭头函数、函数形参默认值、rest参数、拓展运算符、新增数据类型（Set、Map、Symbol、BigInt）、promise、async/await等。</li></ul><h4 id="二、var、let、const的区别"><a href="#二、var、let、const的区别" class="headerlink" title="二、var、let、const的区别"></a>二、var、let、const的区别</h4><table><thead><tr><th align="center">区别</th><th align="center">var</th><th align="center">let</th><th align="center">const</th></tr></thead><tbody><tr><td align="center">是否有块级作用域</td><td align="center">❌</td><td align="center">✔</td><td align="center">✔</td></tr><tr><td align="center">是否存在变量提升</td><td align="center">✔</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">是否添加全局属性</td><td align="center">✔</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">能否重复声明变量</td><td align="center">✔</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">是否存在暂时性死区</td><td align="center">❌</td><td align="center">✔</td><td align="center">✔</td></tr><tr><td align="center">是否必须设置初始值</td><td align="center">❌</td><td align="center">❌</td><td align="center">✔</td></tr><tr><td align="center">能否改变指针指向</td><td align="center">✔</td><td align="center">✔</td><td align="center">❌</td></tr></tbody></table><h4 id="三、箭头函数与普通函数的区别"><a href="#三、箭头函数与普通函数的区别" class="headerlink" title="三、箭头函数与普通函数的区别"></a>三、箭头函数与普通函数的区别</h4><ul><li><strong>箭头函数比普通函数更加简洁</strong><ul><li>如果只有一个参数，可以省去参数的括号。</li><li>如果函数体的返回值只有一句，可以省略大括号，且必须省略return。</li></ul></li><li><strong>箭头函数没有自己的this</strong><ul><li>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</li></ul></li><li><strong>call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong><ul><li>箭头函数的this指向要么是window，要么是它的外层。</li></ul></li><li><strong>箭头函数不能作为构造函数使用</strong><ul><li>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数；new操作符的实现步骤如下：<ul><li>1.创建一个对象</li><li>2.将构造函数的作用域赋给新对象（也就是将对象的proto属性指向构造函数的prototype属性）</li><li>3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</li><li>4.返回新的对象，所以，上面的第二、三步，箭头函数都是没有办法执行的</li></ul></li></ul></li><li><strong>箭头函数没有自己的arguments</strong><ul><li>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</li></ul></li><li><strong>箭头函数没有prototype</strong></li><li><strong>箭头函数不能用作Generator函数，不能使用yield关键字</strong></li></ul><h4 id="四、箭头函数的this指向"><a href="#四、箭头函数的this指向" class="headerlink" title="四、箭头函数的this指向"></a>四、箭头函数的this指向</h4><ul><li>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。箭头函数的this指向外层函数的this。</li></ul><h4 id="五、扩展运算符的作用及使用场景"><a href="#五、扩展运算符的作用及使用场景" class="headerlink" title="五、扩展运算符的作用及使用场景"></a>五、扩展运算符的作用及使用场景</h4><ul><li><strong>对象扩展运算符</strong><ul><li>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。扩展运算符对对象实例的拷贝属于浅拷贝。</li></ul></li><li><strong>数组扩展运算符</strong><ul><li>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</li></ul></li></ul><h4 id="六、对象与数组的解构"><a href="#六、对象与数组的解构" class="headerlink" title="六、对象与数组的解构"></a>六、对象与数组的解构</h4><ul><li>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。</li><li><strong>对象的解构</strong><ul><li>在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。</li></ul></li><li><strong>数组的解构</strong><ul><li>在解构数组时，以元素的位置为匹配条件来提取想要的数据的。</li></ul></li></ul><h4 id="七、模板语法"><a href="#七、模板语法" class="headerlink" title="七、模板语法"></a>七、模板语法</h4><ul><li>允许用**${}**的方式嵌入变量，优势有两个：<ul><li>在模板字符串中，空格、缩进、换行都会被保留，可以识别html代码。</li><li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收与内存泄漏</title>
      <link href="/2022/05/25/la-ji-hui-shou-yu-nei-cun-xie-lou/"/>
      <url>/2022/05/25/la-ji-hui-shou-yu-nei-cun-xie-lou/</url>
      
        <content type="html"><![CDATA[<h4 id="一、浏览器的垃圾回收机制"><a href="#一、浏览器的垃圾回收机制" class="headerlink" title="一、浏览器的垃圾回收机制"></a>一、浏览器的垃圾回收机制</h4><h5 id="1-垃圾回收的概念"><a href="#1-垃圾回收的概念" class="headerlink" title="1.垃圾回收的概念"></a>1.垃圾回收的概念</h5><ul><li><strong>JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</strong></li></ul><h5 id="2-垃圾回收的机制"><a href="#2-垃圾回收的机制" class="headerlink" title="2.垃圾回收的机制"></a>2.垃圾回收的机制</h5><ul><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li><li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li><li>当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li></ul><h5 id="3-垃圾回收的方式"><a href="#3-垃圾回收的方式" class="headerlink" title="3.垃圾回收的方式"></a>3.垃圾回收的方式</h5><ul><li>浏览器通常使用的垃圾回收方法有两种：<strong>标记清除</strong>，<strong>引用计数</strong>。<ul><li>标记清除<ul><li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li></ul></li><li>引用计数<ul><li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li><li>这种方法会引起循环引用的问题：例如： obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li></ul></li></ul></li></ul><h5 id="4-减少垃圾回收的方法"><a href="#4-减少垃圾回收的方法" class="headerlink" title="4.减少垃圾回收的方法"></a>4.减少垃圾回收的方法</h5><ul><li>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以<strong>应该尽量减少垃圾回收</strong>。</li><li><strong>对数组进行优化</strong><ul><li>在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li></ul></li><li><strong>对object进行优化</strong><ul><li>对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li></ul></li><li><strong>对函数进行优化</strong><ul><li>在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li></ul></li></ul><h4 id="二、导致内存泄漏的情况"><a href="#二、导致内存泄漏的情况" class="headerlink" title="二、导致内存泄漏的情况"></a>二、导致内存泄漏的情况</h4><ul><li>内存泄漏：<strong>无法垃圾回收就是内存泄露</strong>。</li><li>可能情况如下：<ul><li><strong>意外的全局变量</strong><ul><li>由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li></ul></li><li><strong>被遗忘的计时器或回调函数</strong><ul><li>设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li></ul></li><li><strong>脱离 DOM 的引用</strong><ul><li>获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li></ul></li><li><strong>闭包</strong><ul><li>不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS执行机制</title>
      <link href="/2022/05/24/js-zhi-xing-ji-zhi/"/>
      <url>/2022/05/24/js-zhi-xing-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h4 id="一、JS执行机制"><a href="#一、JS执行机制" class="headerlink" title="一、JS执行机制"></a>一、JS执行机制</h4><ul><li><p>JS语言有个特点是单线程，即同一时间只能做一件事。单线程就意味着，所有的任务需要排队，前一个任务结束，才会执行后一个任务，可能造成页面渲染不连贯。</p></li><li><p>为了解决这个问题，利用多核CPU的计算能力，允许JS脚本创建多个线程，即<strong>同步</strong>和<strong>异步</strong>。</p></li><li><p>同步任务：</p><ul><li><strong>同步任务都在主线程上执行，形成一个执行栈。</strong></li><li>前一个任务结束后再去执行下一个任务，程序的执行顺序与任务的排列顺序是一致的同步的。</li><li>比如做饭的同步做法，我们要烧水煮饭，等水开了，再去切菜，炒菜。</li></ul></li><li><p>异步任务：</p><ul><li><p><strong>通过回调函数实现的</strong>，异步任务相关回调函数添加到任务队列中(任务队列也称为消息队列)。</p></li><li><p>在做一件事的同时，还可以去处理其他的事情。</p></li><li><p>比如做饭的异步做法，在烧水的同时，利用这段时间，去切菜，炒菜。</p><ul><li>异步任务分类：<ul><li>1.普通事件，如click、resize等。</li><li>2.资源加载，如load、error等。</li><li>3.定时器，包括setTimeout、setInterval等。</li></ul></li></ul></li></ul></li><li><p><strong>同步和异步本质的区别：在这条”流水线”上各个流程的执行顺序不同。</strong></p></li><li><p><strong>JS执行机制步骤：</strong></p><ul><li><p>由于主线程不断地重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环，即event loop。</p></li><li><p><input disabled type="checkbox"> 先执行执行栈中的同步任务。</p></li><li><p><input disabled type="checkbox"> 然后异步任务(回调函数)放任务队列中。</p></li><li><p><input disabled type="checkbox"> 一旦执行栈中的所有同步任务执行完毕，系统就会按照次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</p></li></ul><img src="/2022/05/24/js-zhi-xing-ji-zhi/%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png" style="zoom:60%;"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this的指向</title>
      <link href="/2022/05/24/this-de-zhi-xiang/"/>
      <url>/2022/05/24/this-de-zhi-xiang/</url>
      
        <content type="html"><![CDATA[<h4 id="一、this的指向分类"><a href="#一、this的指向分类" class="headerlink" title="一、this的指向分类"></a>一、this的指向分类</h4><table><thead><tr><th align="center">分类</th><th align="center">this指向</th></tr></thead><tbody><tr><td align="center">普通函数</td><td align="center">window</td></tr><tr><td align="center">构造函数</td><td align="center">实例对象，原型对象里面的方法也指向实例对象</td></tr><tr><td align="center">对象方法</td><td align="center">该方法所属对象。若对象中的方法为普通函数写法吗，则this指向该方法所属对象，若为箭头函数，则this指向为window</td></tr><tr><td align="center">事件绑定函数</td><td align="center">绑定事件对象</td></tr><tr><td align="center">定时器</td><td align="center">window</td></tr><tr><td align="center">立即执行函数</td><td align="center">window</td></tr><tr><td align="center">箭头函数</td><td align="center">外层作用域中的this（且this指向不可改变）</td></tr></tbody></table><h4 id="二、改变函数内部this指向"><a href="#二、改变函数内部this指向" class="headerlink" title="二、改变函数内部this指向"></a>二、改变函数内部this指向</h4><h5 id="1-函数名称-call（this要指向的，传递的参数1，…）"><a href="#1-函数名称-call（this要指向的，传递的参数1，…）" class="headerlink" title="1.函数名称.call（this要指向的，传递的参数1，…）"></a>1.函数名称.call（this要指向的，传递的参数1，…）</h5><ul><li><p>调用函数，并改变this指向。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'zs'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token comment">// this指向obj这个对象</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token comment">// 6</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="2-函数名-apply（this要指向的，-传递的参数1，…-）"><a href="#2-函数名-apply（this要指向的，-传递的参数1，…-）" class="headerlink" title="2.函数名.apply（this要指向的，[传递的参数1，…]）"></a>2.函数名.apply（this要指向的，[传递的参数1，…]）</h5><ul><li><p>调用函数，并改变this指向，传递的参数必须是数组。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">171</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">]</span><span class="token comment">// 利用apply传递数组（伪数组），借助数学内置对象求数组最大值/最小值</span><span class="token keyword">var</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">,</span> arr<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token comment">// 171</span><span class="token keyword">var</span> min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">,</span> arr<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>min<span class="token punctuation">)</span><span class="token comment">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="3-函数名-bind（this要指向的，传递的参数1，…）"><a href="#3-函数名-bind（this要指向的，传递的参数1，…）" class="headerlink" title="3.函数名.bind（this要指向的，传递的参数1，…）"></a>3.函数名.bind（this要指向的，传递的参数1，…）</h5><ul><li><p>不调用函数，但改变this指向，调用需要fn.bind(…)( )。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>按钮1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>按钮2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>按钮3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token comment">// 获取所有的按钮元素</span>    <span class="token keyword">let</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> btns<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        btns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 点击后禁用按钮</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>disabled <span class="token operator">=</span> <span class="token boolean">true</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 2秒后解除禁用该按钮</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>disable <span class="token operator">=</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2022/05/24/bi-bao/"/>
      <url>/2022/05/24/bi-bao/</url>
      
        <content type="html"><![CDATA[<h4 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h4><ul><li><p>JavaScript作用域：分为全局作用域、局部作用域。变量在某个范围内起作用和效果，目的是为了提高程序的可靠性和减少命名冲突。</p></li><li><p>变量的作用域：根据作用域的不同我们变量分为全局变量和局部变量。<strong>两种变量其主要区别是函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。</strong></p></li><li><p>作用域链：</p><ul><li><p><strong>根据内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称为作用域链</strong>。</p></li><li><p>只要是代码，就至少有一个作用域。</p></li><li><p>写在函数内部的局部作用域。</p></li><li><p>如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。</p></li></ul></li></ul><h5 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1.全局变量"></a>1.全局变量</h5><ul><li>概念：在全局作用域下的变量，在全局下都可以使用。</li><li>如果在函数内部没有声明直接赋值的变量也属于全局变量。</li><li>只有浏览器关闭的时，全局变量才会销毁，比较占内存资源。<ul><li>全局作用域：整个script标签中，或者是一个单独的js文件。</li></ul></li></ul><h5 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2.局部变量"></a>2.局部变量</h5><ul><li>在局部作用域下变量，即在函数内部的变量就是局部变量，只能在函数内部使用。</li><li>函数的形参也可以看做是局部变量。</li><li>当我们程序执行完毕时，局部变量就会销毁，比较节约内存资源。<ul><li>局部作用域(函数作用域)：在函数内部就是局部作用域，这个代码的名字(变量)只在函数内部起作用和效果。</li></ul></li></ul><h4 id="二、理解闭包"><a href="#二、理解闭包" class="headerlink" title="二、理解闭包"></a>二、理解闭包</h4><h5 id="1-闭包的概念"><a href="#1-闭包的概念" class="headerlink" title="1.闭包的概念"></a>1.闭包的概念</h5><ul><li><strong>闭包是指有权访问另外一个函数作用域中的局部变量的函数</strong>。声明在一个函数中的函数，叫做闭包函数。而且内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</li></ul><h5 id="2-闭包的特点"><a href="#2-闭包的特点" class="headerlink" title="2.闭包的特点"></a>2.闭包的特点</h5><ul><li>让外部访问函数内部变量成为可能。</li><li>局部变量会常驻在内存中。</li><li>可以避免使用全局变量，防止全局变量污染。</li><li>会造成内存泄漏（有一块内存空间被长期占用，而不被释放）。</li></ul><h5 id="3-闭包的分析"><a href="#3-闭包的分析" class="headerlink" title="3.闭包的分析"></a>3.闭包的分析</h5><ul><li>闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，并且互不干扰。</li><li>闭包会发生内存泄漏，每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址。</li><li>但当外部函数运行结束甚至销毁时，局部的变量key=value,尽管key被垃圾回收机制给回收了，但是value仍不会被回收，会变成一个自由变量留下引用的指针。</li></ul><h5 id="4-闭包的实现案例"><a href="#4-闭包的实现案例" class="headerlink" title="4.闭包的实现案例"></a>4.闭包的实现案例</h5><ul><li><p>利用闭包的方式，输出点击项的索引值</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>closure<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>苹果<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>香蕉<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>橘子<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>西瓜<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token comment">// 获取所有的li元素</span><span class="token keyword">let</span> lis <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'.closure li'</span><span class="token punctuation">)</span>    <span class="token comment">// 利用for循环创建了4个立即执行函数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lis<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>利用闭包的方式，3秒钟之后，打印所有li元素的内容</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>closure<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>苹果<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>香蕉<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>橘子<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>西瓜<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token comment">// 获取所有的li元素</span><span class="token keyword">let</span> lis <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'.closure li'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lis<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack优化</title>
      <link href="/2022/05/23/webpack-you-hua/"/>
      <url>/2022/05/23/webpack-you-hua/</url>
      
        <content type="html"><![CDATA[<h4 id="一、使用webpack优化前端性能方法"><a href="#一、使用webpack优化前端性能方法" class="headerlink" title="一、使用webpack优化前端性能方法"></a>一、使用webpack优化前端性能方法</h4><ul><li><em>⽤webpack优化前端性能是指优化webpack的输出结果,让打包的最终结果在浏览器运⾏快速⾼效。</em></li><li>可通过webpack优化前端的手段：<ul><li><strong>代码压缩</strong>（删除多余的代码、注释、简化代码的写法等等⽅式）<ul><li>HTML文件代码压缩<ul><li>使用HTMLWebpackPlugin插件来生成HTML的模板时候，通过配置属性minify进行HTML优化。</li></ul></li><li>CSS代码压缩<ul><li>利⽤ cssnano （css-loader?minimize）来压缩css。</li></ul></li><li>JS代码压缩<ul><li>利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件。</li></ul></li></ul></li><li><strong>文件大小压缩</strong><ul><li>对文件的大小进行压缩，减少http传输过程中宽带的损耗。</li></ul></li><li><strong>图片压缩</strong></li><li><strong>Tree Shaking</strong><ul><li>将代码中永远不会⾛到的⽚段删除掉（消除死代码）。可以通过在启动webpack时追加参数 –optimize-minimize 来实现。</li></ul></li><li><strong>代码分离</strong><ul><li>代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存。</li></ul></li><li><strong>提取公共第三⽅库</strong><ul><li>SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码 。</li></ul></li></ul></li></ul><h4 id="二、提高webpack构建速度方法"><a href="#二、提高webpack构建速度方法" class="headerlink" title="二、提高webpack构建速度方法"></a>二、提高webpack构建速度方法</h4><ul><li><em>优化webpack构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手。</em><ul><li>优化loader配置<ul><li>在使用loader时，可以通过配置include、exclude、test属性来匹配文件，缩小文件的搜索范围，优化搜索时间</li></ul></li><li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码</li><li>通过 externals 配置来提取常⽤库，脱离webpack打包，不被打⼊bundle中，从⽽减少打包时间</li><li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来，让⼀些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间</li><li>使⽤ Happypack 实现多线程加速编译 </li><li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度</li><li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码 </li><li>利⽤缓存提⾼rebuild效率</li></ul></li></ul><h4 id="三、减少webpack打包时间方法"><a href="#三、减少webpack打包时间方法" class="headerlink" title="三、减少webpack打包时间方法"></a>三、减少webpack打包时间方法</h4><ul><li><p><strong>优化 Loader</strong></p><ul><li><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。</p><ul><li><p>可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">loaders</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'babel-loader?cacheDirectory=true'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>优化 Loader 的文件搜索范围。</p><ul><li><p>对于 Babel 来说，希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>                <span class="token comment">// js文件才使用babel</span><span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>                <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>                <span class="token comment">// 只在src文件夹下查找</span><span class="token literal-property property">include</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token comment">// 不会去查找的路径</span><span class="token literal-property property">exclude</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">node_modules</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li></ul></li><li><p><strong>HappyPack</strong></p><ul><li><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">loaders</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span class="token literal-property property">include</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token literal-property property">exclude</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">node_modules</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span class="token comment">// id后面的内容对应下面</span>            <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'happypack/loader?id=happybabel'</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">HappyPack</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'happybabel'</span><span class="token punctuation">,</span>        <span class="token literal-property property">loaders</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'babel-loader?cacheDirectory'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token comment">// 开启4个线程</span>        <span class="token literal-property property">threads</span><span class="token operator">:</span> <span class="token number">4</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>DllPlugin</strong></p><ul><li>DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</li></ul></li><li><p><strong>代码压缩</strong></p><ul><li>在 Webpack3 中，一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。在 Webpack4 中，不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。</li></ul></li><li><p><strong>其他</strong></p><ul><li>resolve.extensions<ul><li>用来表明文件后缀列表，默认查找顺序是 [‘.js’, ‘.json’]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面。</li></ul></li><li>resolve.alias<ul><li>可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径。</li></ul></li><li>module.noParse<ul><li>如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助。</li></ul></li></ul></li></ul><h4 id="四、减少webpack打包体积方法"><a href="#四、减少webpack打包体积方法" class="headerlink" title="四、减少webpack打包体积方法"></a>四、减少webpack打包体积方法</h4><ul><li><p><strong>按需加载</strong></p><ul><li>在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，这时候就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。</li></ul></li><li><p><strong>Scope Hoisting</strong></p><ul><li><p>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">optimization</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">concatenateModules</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>Tree Shaking</strong></p><ul><li>Tree Shaking 可以实现删除项目中未被引用的代码（死代码）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片优化</title>
      <link href="/2022/05/23/tu-pian-you-hua/"/>
      <url>/2022/05/23/tu-pian-you-hua/</url>
      
        <content type="html"><![CDATA[<h4 id="一、常见的图片格式"><a href="#一、常见的图片格式" class="headerlink" title="一、常见的图片格式"></a>一、常见的图片格式</h4><ul><li><strong>BMP</strong><ul><li>是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</li></ul></li><li><strong>GIF</strong><ul><li>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</li></ul></li><li><strong>JPEG</strong><ul><li>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</li></ul></li><li><strong>PNG-8</strong><ul><li>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</li></ul></li><li><strong>PNG-24</strong><ul><li>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</li></ul></li><li><strong>SVG</strong><ul><li>SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。</li></ul></li><li><strong>WebP</strong><ul><li>WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。<ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%。</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%。</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul></li></ul></li></ul><h4 id="二、进行图片优化"><a href="#二、进行图片优化" class="headerlink" title="二、进行图片优化"></a>二、进行图片优化</h4><ul><li>不用图片，很多时候会使用到很多修饰类图片，其实这类<strong>修饰图片完全可以用 CSS</strong> 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li><strong>小图使用 base64</strong> 格式。</li><li>将<strong>多个图标</strong>文件整合到一张图片中（<strong>精灵图</strong>）。</li><li>选择正确的图片格式：<ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好。</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替。</li><li>照片使用 JPEG。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN</title>
      <link href="/2022/05/23/cdn/"/>
      <url>/2022/05/23/cdn/</url>
      
        <content type="html"><![CDATA[<h4 id="一、CDN的概念"><a href="#一、CDN的概念" class="headerlink" title="一、CDN的概念"></a>一、CDN的概念</h4><ul><li>概念：CDN（Content Delivery Network）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</li><li>即<strong>内容分发网络</strong>。</li></ul><h4 id="二、CDN的使用场景"><a href="#二、CDN的使用场景" class="headerlink" title="二、CDN的使用场景"></a>二、CDN的使用场景</h4><ul><li>使用第三方的CDN服务<ul><li>如果想要开源一些项目，可以使用第三方的CDN服务。</li></ul></li><li>使用CDN进行静态资源的缓存<ul><li>将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。</li></ul></li><li>直播传送<ul><li>直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</li></ul></li></ul><h4 id="三、CDN的作用"><a href="#三、CDN的作用" class="headerlink" title="三、CDN的作用"></a>三、CDN的作用</h4><ul><li>CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。<ul><li>在<strong>性能方面</strong>，引入CDN的作用在于：<ul><li>用户收到的内容来自最近的数据中心，延迟更低，内容加载更快。</li><li>部分资源请求分配给了CDN，减少了服务器的负载。</li></ul></li><li>在<strong>安全方面</strong>，CDN有助于防御DDoS、MITM等网络攻击：<ul><li>针对DDoS：通过监控分析异常流量，限制其请求频率。</li><li>针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信。</li></ul></li><li>除此之外，CDN作为一种基础的<strong>云服务</strong>，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。</li></ul></li></ul><h4 id="四、CDN的原理"><a href="#四、CDN的原理" class="headerlink" title="四、CDN的原理"></a>四、CDN的原理</h4><ul><li><p><em><strong>用户未使用CDN缓存资源的过程</strong></em></p><ul><li>1.浏览器通过DNS对域名进行解析，依次得到此域名对应的IP地址。</li><li>2.浏览器根据得到的IP地址，向域名的服务主机发送数据请求。</li><li>3.服务器向浏览器返回响应数据。</li></ul></li><li><p><em><strong>用户使用CDN缓存资源的过程</strong></em></p><ul><li>1.对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。<ul><li>CNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。</li></ul></li><li>2.CDN专用DNS服务器将CDN的全局负载均衡设备IP地址返回给用户。</li><li>3.用户向CDN的全局负载均衡设备发起数据请求。</li><li>4.CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备。</li><li>5.区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备。</li><li>6.全局负载均衡设备把服务器的IP地址返回给用户，告诉用户向这台设备发起请求。</li><li>7.用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。</li><li>8.如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。</li></ul><img src="/2022/05/23/cdn/CDN.png" style="zoom:60%;"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>懒加载</title>
      <link href="/2022/05/23/lan-jia-zai/"/>
      <url>/2022/05/23/lan-jia-zai/</url>
      
        <content type="html"><![CDATA[<h4 id="一、懒加载的概念"><a href="#一、懒加载的概念" class="headerlink" title="一、懒加载的概念"></a>一、懒加载的概念</h4><ul><li>概念：懒加载也叫做<strong>延迟加载、按需加载</strong>，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，<strong>减少了服务器的负载</strong>。懒加载适用于图片较多，页面列表较长（长列表）的场景中。</li></ul><h4 id="二、懒加载的特点"><a href="#二、懒加载的特点" class="headerlink" title="二、懒加载的特点"></a>二、懒加载的特点</h4><ul><li><strong>减少无用资源的加载</strong><ul><li>使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</li></ul></li><li><strong>提升用户体验</strong><ul><li>如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</li></ul></li><li><strong>防止加载过多图片而影响其他资源文件的加载</strong><ul><li>加载过多图片可能会影响网站应用的正常使用。</li></ul></li></ul><h4 id="三、懒加载的实现原理"><a href="#三、懒加载的实现原理" class="headerlink" title="三、懒加载的实现原理"></a>三、懒加载的实现原理</h4><p>​    <img src="/2022/05/23/lan-jia-zai/%E6%87%92%E5%8A%A0%E8%BD%BD.png" style="zoom:60%;"></p><ul><li><p>图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，<strong>将data-xxx中图片的路径赋值给src</strong>，这样就实现了图片的按需加载，即懒加载。</p></li><li><p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在<strong>可视区域时</strong>，获取图片的真实地址并赋值给图片即可。</p></li><li><p>使用原生JavaScript实现懒加载</p><ul><li><p>window.innerHeight 是浏览器可视区的高度</p></li><li><p>document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动的过的距离</p></li><li><p>imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）</p></li><li><p><strong>图片加载条件：img.offsetTop &lt; window.innerHeight + document.body.scrollTop</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loading.gif<span class="token punctuation">"</span></span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pic.png<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loading.gif<span class="token punctuation">"</span></span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pic.png<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loading.gif<span class="token punctuation">"</span></span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pic.png<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loading.gif<span class="token punctuation">"</span></span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pic.png<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loading.gif<span class="token punctuation">"</span></span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pic.png<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token comment">// 获取全部的图片元素</span>    <span class="token keyword">let</span> imgs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span>    <span class="token keyword">function</span> <span class="token function">lazyLoad</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取浏览器滚动的过的距离</span>        <span class="token keyword">var</span> scrollTop <span class="token operator">=</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop <span class="token operator">||</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop        <span class="token comment">// 获取浏览器可视区的高度</span>        <span class="token keyword">var</span> winHeight <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> imgs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 判断是否满足图片加载条件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>imgs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>offsetTop <span class="token operator">&lt;</span> scrollTop <span class="token operator">+</span> winHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>                imgs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>src <span class="token operator">=</span> imgs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'data-src'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    window<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> <span class="token function">lazyLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="四、懒加载与预加载的区别"><a href="#四、懒加载与预加载的区别" class="headerlink" title="四、懒加载与预加载的区别"></a>四、懒加载与预加载的区别</h4><ul><li>这两种方式都是提高网页性能的方式，两者主要区别是一个是<strong>提前加载</strong>，一个是<strong>迟缓甚至不加载</strong>。<strong>懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</strong></li><li><em>懒加载</em>：<ul><li>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</li></ul></li><li><em>预加载</em>：<ul><li>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 src属性，来实现图片的预加载。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>减少回流与重绘</title>
      <link href="/2022/05/23/jian-shao-hui-liu-yu-chong-hui/"/>
      <url>/2022/05/23/jian-shao-hui-liu-yu-chong-hui/</url>
      
        <content type="html"><![CDATA[<h4 id="一、回流-x2F-重排"><a href="#一、回流-x2F-重排" class="headerlink" title="一、回流/重排"></a>一、回流/重排</h4><ul><li>概念：当渲染树中部分或者全部<strong>元素的尺寸、结构或者属性发生变化</strong>时，浏览器会重新渲染部分或者全部文档的过程就称为回流/重排。</li><li>触发条件：<ul><li>页面的首次渲染</li><li>浏览器的窗口大小发生变化</li><li>元素的内容发生变化</li><li>元素的尺寸或者位置发生变化</li><li>元素的字体大小发生变化</li><li>激活CSS伪类</li><li>查询某些属性或者调用某些方法</li><li>添加或者删除可见的DOM元素</li></ul></li></ul><h4 id="二、重绘"><a href="#二、重绘" class="headerlink" title="二、重绘"></a>二、重绘</h4><ul><li>概念：当页面中某些元素的<strong>样式发生变化</strong>，但是<strong>不会影响其在文档流中的位置</strong>时，浏览器就会对元素进行重新绘制，这个过程就是重绘。</li><li>触发条件：<ul><li>color、background 相关属性：background-color、background-image 等</li><li>outline 相关属性：outline-color、outline-width 、text-decoration</li><li>border-radius、visibility、box-shadow</li></ul></li></ul><h4 id="三、如何避免回流与重绘"><a href="#三、如何避免回流与重绘" class="headerlink" title="三、如何避免回流与重绘"></a>三、如何避免回流与重绘</h4><ul><li><em><strong>浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列</strong></em><ul><li>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批量处理。这样就会让多次的回流、重绘变成一次回流重绘。</li></ul></li><li><em><strong>CSS</strong></em><ul><li>避免设置多层内联样式。</li><li>如果需要设置动画效果，最好使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素。</li><li>避免使用CSS表达式（例如：calc()）。</li></ul></li><li><em><strong>JS</strong></em><ul><li>避免频繁操作样式，最好将样式列表定义为class并一次性更改class属性。避免频繁操作样式，最好将样式列表定义为class并一次性更改class属性。</li><li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li><li>可以先为元素设置为不可见：display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li></ul></li></ul><h4 id="四、解释上述的documentFragment"><a href="#四、解释上述的documentFragment" class="headerlink" title="四、解释上述的documentFragment"></a>四、解释上述的documentFragment</h4><ul><li>概念：DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</li><li>与直接操作DOM的区别：由于DocumentFragment不会出现在文档树中，将DocumentFragment插入文档树中，相当于把把他的子孙节点插入到文档树中，在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，仅会触发页面的一次重绘，这样就大大提高了页面的性能。</li></ul><h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p><strong>回流一定重绘，重绘不一定回流。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅拷贝与深拷贝</title>
      <link href="/2022/05/22/qian-kao-bei-yu-shen-kao-bei/"/>
      <url>/2022/05/22/qian-kao-bei-yu-shen-kao-bei/</url>
      
        <content type="html"><![CDATA[<h4 id="一、数据类型存储"><a href="#一、数据类型存储" class="headerlink" title="一、数据类型存储"></a>一、数据类型存储</h4><ul><li><p>在JavaScript中存在两大数据类型：基本类型、引用类型。</p><ul><li><p>基本数据类型存放在栈中，是一段简单的数据段，<strong>数据大小确定，内存空间大小可以分配</strong>，是直接按值存放的，可以<strong>按值访问</strong>。</p></li><li><p>引用数据类型存放在堆中，变量在栈中保存的是<strong>指向堆内存的地址值</strong>，这个地址值指向对应的对象类型，访问堆内存中的对象是<strong>通过地址值访问</strong>的。</p><img src="/2022/05/22/qian-kao-bei-yu-shen-kao-bei/%E5%A0%86%E6%A0%88.png" style="zoom:60%;"></li></ul></li></ul><h4 id="二、浅拷贝"><a href="#二、浅拷贝" class="headerlink" title="二、浅拷贝"></a>二、浅拷贝</h4><ul><li><p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝。</p></li><li><p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址。</p></li><li><p>即浅拷贝是拷贝一层。</p></li><li><p>下面简单实现一个浅拷贝：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">shallowClone</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> prop <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>newObj<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> newObj<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在JavaScript中，<em>存在浅拷贝的现象</em>有：</p><ul><li><code>Object.assign()</code></li><li><code>Array.prototype.slice()</code></li><li><code>Array.prototype.concat()</code></li><li><code>使用扩展运算符实现的复制</code></li></ul></li><li><p><strong>Object.assign()</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>    <span class="token literal-property property">nature</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'smart'</span><span class="token punctuation">,</span> <span class="token string">'good'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token literal-property property">names</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token literal-property property">name1</span><span class="token operator">:</span> <span class="token string">'fx'</span><span class="token punctuation">,</span>        <span class="token literal-property property">name2</span><span class="token operator">:</span> <span class="token string">'xka'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function-variable function">love</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fx is a great girl'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> newObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> fxObj<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>slice()</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fxArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'One'</span><span class="token punctuation">,</span> <span class="token string">'Two'</span><span class="token punctuation">,</span> <span class="token string">'Three'</span><span class="token punctuation">]</span><span class="token keyword">const</span> fxArrs <span class="token operator">=</span> fxArr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>fxArrs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'love'</span>consloe<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fxArr<span class="token punctuation">)</span><span class="token comment">// ['One', 'Two', 'Three']</span>consloe<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fxArrs<span class="token punctuation">)</span><span class="token comment">// ['One', 'love', 'Three']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>concat()</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fxArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'One'</span><span class="token punctuation">,</span> <span class="token string">'Two'</span><span class="token punctuation">,</span> <span class="token string">'Three'</span><span class="token punctuation">]</span><span class="token keyword">const</span> fxArrs <span class="token operator">=</span> fxArr<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fxArrs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'love'</span>consloe<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fxArr<span class="token punctuation">)</span><span class="token comment">// ['One', 'Two', 'Three']</span>consloe<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fxArrs<span class="token punctuation">)</span><span class="token comment">// ['One', 'love', 'Three']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>扩展运算符</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fxArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'One'</span><span class="token punctuation">,</span> <span class="token string">'Two'</span><span class="token punctuation">,</span> <span class="token string">'Three'</span><span class="token punctuation">]</span><span class="token keyword">const</span> fxArrs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>fxArr<span class="token punctuation">]</span>fxArrs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'love'</span>consloe<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fxArr<span class="token punctuation">)</span><span class="token comment">// ['One', 'Two', 'Three']</span>consloe<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fxArrs<span class="token punctuation">)</span><span class="token comment">// ['One', 'love', 'Three']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="三、深拷贝"><a href="#三、深拷贝" class="headerlink" title="三、深拷贝"></a>三、深拷贝</h4><ul><li><p>深拷贝开辟一个新的栈，两个对象相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。</p></li><li><p><em>常见的深拷贝方式</em>有：</p><ul><li><code>_.cloneDeep()</code></li><li><code>jQuery.extend()</code></li><li><code>JSON.stringify()</code></li><li><code>循环递归</code></li></ul></li><li><p><strong>_.cloneDeep()</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> _ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">f</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">g</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">cloneDeep</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>b<span class="token punctuation">.</span>f <span class="token operator">===</span> obj2<span class="token punctuation">.</span>b<span class="token punctuation">.</span>f<span class="token punctuation">)</span><span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>jQuery.extend()</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> $ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'jquery'</span><span class="token punctuation">)</span><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">f</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">g</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> obj1<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>b<span class="token punctuation">.</span>f <span class="token operator">===</span> obj2<span class="token punctuation">.</span>b<span class="token punctuation">.</span>f<span class="token punctuation">)</span><span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>JSON.stringify()</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'A'</span><span class="token punctuation">,</span>    <span class="token literal-property property">name1</span><span class="token operator">:</span> <span class="token string">'undefined'</span><span class="token punctuation">,</span>    <span class="token function-variable function">name2</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token literal-property property">name3</span><span class="token operator">:</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 会忽略undefined、Symbol、函数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token comment">// { name: 'A' }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>循环递归</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">deepClone</span> <span class="token punctuation">(</span>obj<span class="token punctuation">,</span> hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token comment">// 如果是null或者undefined，就不进行拷贝操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>    <span class="token comment">// 可能是对象或者普通的值，如果是函数的话不需要深拷贝</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'Object'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj    <span class="token comment">// 如果是对象，就进行深拷贝</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> hash<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>    <span class="token keyword">let</span> cloneObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 找到的是所属类型原型上的constructor，而原型上的constructor指向的是当前类本身</span>    hash<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> cloneObj<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 实现一个递归拷贝</span>            cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cloneObj<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="四、区别"><a href="#四、区别" class="headerlink" title="四、区别"></a>四、区别</h4><ul><li><p>浅拷贝只复制内存地址，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 浅拷贝</span><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'init'</span><span class="token punctuation">,</span>    <span class="token literal-property property">arr</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">const</span> obj3 <span class="token operator">=</span> <span class="token function">shallowClone</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token comment">// 一个浅拷贝方法</span>obj3<span class="token punctuation">.</span>name <span class="token operator">=</span> 'update‘obj3<span class="token punctuation">.</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token comment">// 新旧对象还是共享同一块内存</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj1'</span><span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token comment">// obj1 { name: 'init', arr: [1, [5, 6, 7], 4] }</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj3'</span><span class="token punctuation">,</span> obj3<span class="token punctuation">)</span><span class="token comment">// obj3 { name: 'update', arr: [1, [5, 6, 7], 4] }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>深拷贝会另外创造一个一模一样的对象，新对象与原对象不共享内存，修改新对象不会改到原对象。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 深拷贝</span><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'init'</span><span class="token punctuation">,</span>    <span class="token literal-property property">arr</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">const</span> obj4 <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token comment">// 一个深拷贝方法</span>obj4<span class="token punctuation">.</span>name <span class="token operator">=</span> 'update‘obj4<span class="token punctuation">.</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token comment">// 新对象与原对象不共享内存</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj1'</span><span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token comment">// obj1 { name: 'init', arr: [1, [2, 3], 4] }</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj4'</span><span class="token punctuation">,</span> obj4<span class="token punctuation">)</span><span class="token comment">// obj4 { name: 'update', arr: [1, [5, 6, 7], 4] }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>当拷贝类型为引用类型时：</p><ul><li>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址。</li><li>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节点操作</title>
      <link href="/2022/05/22/jie-dian-cao-zuo/"/>
      <url>/2022/05/22/jie-dian-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h4 id="一、节点概述"><a href="#一、节点概述" class="headerlink" title="一、节点概述"></a>一、节点概述</h4><ul><li>网页中的所有内容都是节点(标签、属性、文本、注释等)，使用node表示。HTML、DOM树中的所有节点均可通过JavaScript进行访问，所有HTML元素(节点)均可被修改，也可以创建或删除。</li><li>利用DOM树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。</li><li>一般地，节点至少拥有nodeType(节点类型)、nodeName(节点名称)、nodeValue(节点值)这三个基本属性。在实际开发中，节点操作主要操作的是元素节点。<ul><li>元素节点nodeType为1。</li><li>属性节点nodeType为2。</li><li>文本节点nodeType为3（文本节点包含文字、空格、换行等）。</li></ul></li></ul><h4 id="二、获取父节点"><a href="#二、获取父节点" class="headerlink" title="二、获取父节点"></a>二、获取父节点</h4><p><strong>1.</strong><code>子元素.parentNode</code></p><p>返回某节点的父节点，得到的是离元素最近的父级节点(即亲爸爸)。如果找不到父节点，就返回为null。</p><h4 id="三、获取子节点-伪数组"><a href="#三、获取子节点-伪数组" class="headerlink" title="三、获取子节点(伪数组)"></a>三、获取子节点(伪数组)</h4><p><strong>1.</strong><code>父节点.children</code></p><p>返回所有的子元素节点，只返回子元素节点，其余节点不返回。</p><p>返回第一个子元素节点的写法：<code>父节点.children[0]</code></p><p>返回最后一个子元素节点的写法是：<code>父节点.children[parentNode.children.length - 1]</code></p><h4 id="四、获取兄弟节点"><a href="#四、获取兄弟节点" class="headerlink" title="四、获取兄弟节点"></a>四、获取兄弟节点</h4><ul><li>获取下一个兄弟节点：<code>元素.nextElementSibling</code><ul><li>返回当前元素的下一个兄弟元素节点，如果找不到则返回null。</li></ul></li><li>获取上一个兄弟节点：<code>元素.previousElementSibling</code><ul><li>返回当前元素的上一个兄弟元素节点，如果找不到则返回null。</li></ul></li></ul><h4 id="五、创建节点-x2F-添加节点"><a href="#五、创建节点-x2F-添加节点" class="headerlink" title="五、创建节点/添加节点"></a>五、创建节点/添加节点</h4><ul><li>步骤：先创建节点再添加节点。</li><li>创建节点语法格式：<code>document.createElement('标签名')</code></li><li>添加节点：<ul><li>在<strong>最后面追加</strong>节点：<code>父元素.appendChild(子元素)</code></li><li>在<strong>某个子元素的前面追加</strong>节点：<code>父元素.insertBefore(要插入的元素, 在哪个元素前面)</code></li></ul></li></ul><h4 id="六、删除节点"><a href="#六、删除节点" class="headerlink" title="六、删除节点"></a>六、删除节点</h4><p>1.<code>父元素.removeChild(要删除的元素)</code></p><p>删除节点必须通过父元素删除。</p><h4 id="七、复制节点"><a href="#七、复制节点" class="headerlink" title="七、复制节点"></a>七、复制节点</h4><p>1.<code>元素.cloneNode(布尔值)</code></p><ul><li>默认是fales，是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。</li><li>若为true，是深度拷贝，会复制节点本身以及里面所有的子节点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件委托和排他思想</title>
      <link href="/2022/05/21/shi-jian-wei-tuo-he-pai-ta-si-xiang/"/>
      <url>/2022/05/21/shi-jian-wei-tuo-he-pai-ta-si-xiang/</url>
      
        <content type="html"><![CDATA[<h4 id="一、事件委派"><a href="#一、事件委派" class="headerlink" title="一、事件委派"></a>一、事件委派</h4><h5 id="1-理解DOM事件流"><a href="#1-理解DOM事件流" class="headerlink" title="1.理解DOM事件流"></a>1.理解DOM事件流</h5><ul><li><p>事件流描述的是从页面中接收事件的顺序。事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。</p></li><li><p>DOM事件流分为三个阶段：</p><ul><li>捕获阶段：从上往下</li><li>当前目标阶段</li><li><strong>冒泡阶段</strong>：从下往上</li></ul></li><li><p>事件流如下图所示：</p><img src="/2022/05/21/shi-jian-wei-tuo-he-pai-ta-si-xiang/事件流.png" style="zoom:60%;"></li><li><p>注意事项：</p><ul><li>JavaScript代码中只能执行捕获或者冒泡其中的一个阶段。</li><li>addEventListener(type, listener[, useCapture])第三个参数如果是true，表示在事件捕获阶段调用事件处理程序；如果是false(不写默认就是false)，表示在事件冒泡阶段调用事件处理程序。</li><li>其中有些事件是没有冒泡的，比如onblur、onfocus、onmouseenter、onmouseleave。</li></ul></li></ul><h5 id="2-掌握事件委托"><a href="#2-掌握事件委托" class="headerlink" title="2.掌握事件委托"></a>2.掌握事件委托</h5><ul><li>概念：事件委托也称为事件代理，在jQuery中称为事件委派。</li><li>事件委托的作用：只操作了一次DOM，提高了程序的性能。</li><li>事件委托的优点包括：可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件；实现动态绑定事件。</li><li><strong>事件委托的原理</strong>：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。</li></ul><h4 id="二、排他思想"><a href="#二、排他思想" class="headerlink" title="二、排他思想"></a>二、排他思想</h4><ul><li><p>应用：如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想。</p></li><li><p><strong>排他思想原理</strong>：(1)先所有元素全部清除样式，即干掉其他人；(2)再给当前元素设置样式，即留下自己。</p></li><li><p><em>场景一</em>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 需求：点击哪个按钮，让当前按钮变为粉色，其余不变色</span><span class="token operator">&lt;</span>button<span class="token operator">&gt;</span>按钮<span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token operator">&lt;</span>button<span class="token operator">&gt;</span>按钮<span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token operator">&lt;</span>button<span class="token operator">&gt;</span>按钮<span class="token number">3</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token operator">&lt;</span>button<span class="token operator">&gt;</span>按钮<span class="token number">4</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token operator">&lt;</span>button<span class="token operator">&gt;</span>按钮<span class="token number">5</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token comment">// 获取所有按钮元素</span>    <span class="token keyword">let</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> btns<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 绑定点击事件</span>        btns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">addaddEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> btns<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 干掉其他人</span>                btns<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">''</span>            <span class="token punctuation">}</span>            <span class="token comment">// 留下自己</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">'pink'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><em>场景二</em>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 需求：Tab栏切换时，只有选中项的背景颜色为粉色。默认第一项被选中其背景颜色为粉色，其余项无背景颜色。</span><span class="token comment">// 被选中的tab栏样式</span><span class="token operator">&lt;</span>style type<span class="token operator">=</span><span class="token string">"text/css"</span><span class="token operator">&gt;</span><span class="token punctuation">.</span>active <span class="token punctuation">{</span>        background<span class="token operator">-</span>color<span class="token operator">:</span> pink<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">&lt;</span>style<span class="token operator">&gt;</span><span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"active"</span><span class="token operator">&gt;</span>Tab1<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Tab2<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Tab3<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Tab4<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token comment">// 获取所有的li标签元素</span>    <span class="token keyword">let</span> lis <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lis<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 绑定点击事件</span>        lis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">addaddEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 移除当前类</span>            document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'ul .active'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">'active'</span><span class="token punctuation">)</span>            <span class="token comment">// 为点击的添加类</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'active'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节流与防抖</title>
      <link href="/2022/05/20/jie-liu-yu-fang-dou/"/>
      <url>/2022/05/20/jie-liu-yu-fang-dou/</url>
      
        <content type="html"><![CDATA[<h4 id="一、节流"><a href="#一、节流" class="headerlink" title="一、节流"></a>一、节流</h4><ul><li><p>概念：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。</p></li><li><p>类似于技能CD。</p></li><li><p>应用：点击按钮，轮播图点击左右箭头。</p></li><li><p>插件lodash.js，它里面封装了函数的防抖与节流业务。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>计数器：<span class="token operator">&lt;</span>span<span class="token operator">&gt;</span><span class="token number">0</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token operator">&lt;</span>button<span class="token operator">&gt;</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token comment">// 获取元素</span><span class="token keyword">let</span> span <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token keyword">let</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token comment">// 控制节流阀是否开启或关闭</span><span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token comment">// 需求：在一秒以内，不管点击按钮多少次，计数器数值只能+1</span>btn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>        flag <span class="token operator">=</span> <span class="token boolean">false</span>        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        count<span class="token operator">++</span>    span<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> count        flag <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="二、防抖"><a href="#二、防抖" class="headerlink" title="二、防抖"></a>二、防抖</h4><ul><li><p>概念：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发，只会执行一次。</p></li><li><p>类似于LOL回城被打断。</p></li><li><p>应用：输入框搜索。</p></li><li><p>插件lodash.js，它里面封装了函数的防抖与节流业务。</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;input type="text" @input="inputFn" /&gt;data () {return {timer: null}},methods: {inputFn () {if (this.timer) {clearTimeout(this.timer)}this.timer = setTimeout(() =&gt; {// 发送网络请求}, 3000)}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2022/03/21/hello-world/"/>
      <url>/2022/03/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这是测试！！！<br>这是测试！！！<br>这是测试！！！  </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
